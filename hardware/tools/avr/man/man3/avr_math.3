.TH "<math.h>: Mathematics" 3 "6 Nov 2008" "Version 1.6.4" "avr-libc" \" -*- nroff -*-
.ad l
.nh
.SH NAME
<math.h>: Mathematics \- 
.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBM_PI\fP   3.141592653589793238462643"
.br
.ti -1c
.RI "#define \fBM_SQRT2\fP   1.4142135623730950488016887"
.br
.ti -1c
.RI "#define \fBNAN\fP   __builtin_nan('')"
.br
.ti -1c
.RI "#define \fBINFINITY\fP   __builtin_inf()"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "double \fBcos\fP (double __x)"
.br
.ti -1c
.RI "double \fBfabs\fP (double __x)"
.br
.ti -1c
.RI "double \fBfmod\fP (double __x, double __y)"
.br
.ti -1c
.RI "double \fBmodf\fP (double __x, double *__iptr)"
.br
.ti -1c
.RI "double \fBsin\fP (double __x)"
.br
.ti -1c
.RI "double \fBsqrt\fP (double __x)"
.br
.ti -1c
.RI "double \fBtan\fP (double __x)"
.br
.ti -1c
.RI "double \fBfloor\fP (double __x)"
.br
.ti -1c
.RI "double \fBceil\fP (double __x)"
.br
.ti -1c
.RI "double \fBfrexp\fP (double __x, int *__pexp)"
.br
.ti -1c
.RI "double \fBldexp\fP (double __x, int __exp)"
.br
.ti -1c
.RI "double \fBexp\fP (double __x)"
.br
.ti -1c
.RI "double \fBcosh\fP (double __x)"
.br
.ti -1c
.RI "double \fBsinh\fP (double __x)"
.br
.ti -1c
.RI "double \fBtanh\fP (double __x)"
.br
.ti -1c
.RI "double \fBacos\fP (double __x)"
.br
.ti -1c
.RI "double \fBasin\fP (double __x)"
.br
.ti -1c
.RI "double \fBatan\fP (double __x)"
.br
.ti -1c
.RI "double \fBatan2\fP (double __y, double __x)"
.br
.ti -1c
.RI "double \fBlog\fP (double __x)"
.br
.ti -1c
.RI "double \fBlog10\fP (double __x)"
.br
.ti -1c
.RI "double \fBpow\fP (double __x, double __y)"
.br
.ti -1c
.RI "int \fBisnan\fP (double __x)"
.br
.ti -1c
.RI "int \fBisinf\fP (double __x)"
.br
.ti -1c
.RI "double \fBsquare\fP (double __x)"
.br
.ti -1c
.RI "static double \fBcopysign\fP (double __x, double __y)"
.br
.ti -1c
.RI "double \fBfdim\fP (double __x, double __y)"
.br
.ti -1c
.RI "double \fBfma\fP (double __x, double __y, double __z)"
.br
.ti -1c
.RI "double \fBfmax\fP (double __x, double __y)"
.br
.ti -1c
.RI "double \fBfmin\fP (double __x, double __y)"
.br
.ti -1c
.RI "int \fBsignbit\fP (double __x)"
.br
.ti -1c
.RI "double \fBtrunc\fP (double __x)"
.br
.ti -1c
.RI "static int \fBisfinite\fP (double __x)"
.br
.ti -1c
.RI "double \fBhypot\fP (double __x, double __y)"
.br
.ti -1c
.RI "double \fBround\fP (double __x)"
.br
.ti -1c
.RI "long \fBlround\fP (double __x)"
.br
.ti -1c
.RI "long \fBlrint\fP (double __x)"
.br
.in -1c
.SH "Detailed Description"
.PP 
.PP
.nf
 #include <math.h> 
.fi
.PP
.PP
This header file declares basic mathematics constants and functions.
.PP
\fBNotes:\fP.RS 4

.IP "\(bu" 2
In order to access the functions delcared herein, it is usually also required to additionally link against the library \fClibm.a\fP. See also the related \fBFAQ entry\fP.
.IP "\(bu" 2
Math functions do not raise exceptions and do not change the \fCerrno\fP variable. Therefore the majority of them are declared with const attribute, for better optimization by GCC. 
.PP
.RE
.PP

.SH "Define Documentation"
.PP 
.SS "#define INFINITY   __builtin_inf()"
.PP
INFINITY constant. 
.SS "#define M_PI   3.141592653589793238462643"
.PP
The constant \fCpi\fP. 
.SS "#define M_SQRT2   1.4142135623730950488016887"
.PP
The square root of 2. 
.SS "#define NAN   __builtin_nan('')"
.PP
NAN constant. 
.SH "Function Documentation"
.PP 
.SS "double acos (double __x)"
.PP
The \fBacos()\fP function computes the principal value of the arc cosine of \fI__x\fP. The returned value is in the range [0, pi] radians. A domain error occurs for arguments not in the range [-1, +1]. 
.SS "double asin (double __x)"
.PP
The \fBasin()\fP function computes the principal value of the arc sine of \fI__x\fP. The returned value is in the range [-pi/2, pi/2] radians. A domain error occurs for arguments not in the range [-1, +1]. 
.SS "double atan (double __x)"
.PP
The \fBatan()\fP function computes the principal value of the arc tangent of \fI__x\fP. The returned value is in the range [-pi/2, pi/2] radians. 
.SS "double atan2 (double __y, double __x)"
.PP
The \fBatan2()\fP function computes the principal value of the arc tangent of \fI__y / __x\fP, using the signs of both arguments to determine the quadrant of the return value. The returned value is in the range [-pi, +pi] radians. 
.SS "double ceil (double __x)"
.PP
The \fBceil()\fP function returns the smallest integral value greater than or equal to \fI__x\fP, expressed as a floating-point number. 
.SS "static double copysign (double __x, double __y)\fC [static]\fP"
.PP
The \fBcopysign()\fP function returns \fI__x\fP but with the sign of \fI__y\fP. They work even if \fI__x\fP or \fI__y\fP are NaN or zero. 
.SS "double cos (double __x)"
.PP
The \fBcos()\fP function returns the cosine of \fI__x\fP, measured in radians. 
.SS "double cosh (double __x)"
.PP
The \fBcosh()\fP function returns the hyperbolic cosine of \fI__x\fP. 
.SS "double exp (double __x)"
.PP
The \fBexp()\fP function returns the exponential value of \fI__x\fP. 
.SS "double fabs (double __x)"
.PP
The \fBfabs()\fP function computes the absolute value of a floating-point number \fI__x\fP. 
.SS "double fdim (double __x, double __y)"
.PP
The \fBfdim()\fP function returns \fImax(__x - __y, 0)\fP. If \fI__x\fP or \fI__y\fP or both are NaN, NaN is returned. 
.SS "double floor (double __x)"
.PP
The \fBfloor()\fP function returns the largest integral value less than or equal to \fI__x\fP, expressed as a floating-point number. 
.SS "double fma (double __x, double __y, double __z)"
.PP
The \fBfma()\fP function performs floating-point multiply-add. This is the operation \fI(__x * __y) + __z\fP, but the intermediate result is not rounded to the destination type. This can sometimes improve the precision of a calculation. 
.SS "double fmax (double __x, double __y)"
.PP
The \fBfmax()\fP function returns the greater of the two values \fI__x\fP and \fI__y\fP. If an argument is NaN, the other argument is returned. If both arguments are NaN, NaN is returned. 
.SS "double fmin (double __x, double __y)"
.PP
The \fBfmin()\fP function returns the lesser of the two values \fI__x\fP and \fI__y\fP. If an argument is NaN, the other argument is returned. If both arguments are NaN, NaN is returned. 
.SS "double fmod (double __x, double __y)"
.PP
The function \fBfmod()\fP returns the floating-point remainder of \fI__x / __y\fP. 
.SS "double frexp (double __x, int * __pexp)"
.PP
The \fBfrexp()\fP function breaks a floating-point number into a normalized fraction and an integral power of 2. It stores the integer in the \fCint\fP object pointed to by \fI__pexp\fP.
.PP
If \fI__x\fP is a normal float point number, the \fBfrexp()\fP function returns the value \fCv\fP, such that \fCv\fP has a magnitude in the interval [1/2, 1) or zero, and \fI__x\fP equals \fCv\fP times 2 raised to the power \fI__pexp\fP. If \fI__x\fP is zero, both parts of the result are zero. If \fI__x\fP is not a finite number, the \fBfrexp()\fP returns \fI__x\fP as is and stores 0 by \fI__pexp\fP.
.PP
\fBNote:\fP
.RS 4
This implementation permits a zero pointer as a directive to skip a storing the exponent. 
.RE
.PP

.SS "double hypot (double __x, double __y)"
.PP
The \fBhypot()\fP function returns \fIsqrt(__x*__x + __y*__y)\fP. This is the length of the hypotenuse of a right triangle with sides of length \fI__x\fP and \fI__y\fP, or the distance of the point (\fI__x\fP, \fI__y\fP) from the origin. Using this function instead of the direct formula is wise, since the error is much smaller. No underflow with small \fI__x\fP and \fI__y\fP. No overflow if result is in range. 
.SS "static int isfinite (double __x)\fC [static]\fP"
.PP
The \fBisfinite()\fP function returns a nonzero value if \fI__x\fP is finite: not plus or minus infinity, and not NaN. 
.SS "int isinf (double __x)"
.PP
The function \fBisinf()\fP returns 1 if the argument \fI__x\fP is positive infinity, -1 if \fI__x\fP is negative infinity, and 0 otherwise. 
.SS "int isnan (double __x)"
.PP
The function \fBisnan()\fP returns 1 if the argument \fI__x\fP represents a 'not-a-number' (NaN) object, otherwise 0. 
.SS "double ldexp (double __x, int __exp)"
.PP
The \fBldexp()\fP function multiplies a floating-point number by an integral power of 2.
.PP
The \fBldexp()\fP function returns the value of \fI__x\fP times 2 raised to the power \fI__exp\fP. 
.SS "double log (double __x)"
.PP
The \fBlog()\fP function returns the natural logarithm of argument \fI__x\fP. 
.SS "double log10 (double __x)"
.PP
The \fBlog10()\fP function returns the logarithm of argument \fI__x\fP to base 10. 
.SS "long lrint (double __x)"
.PP
The \fBlrint()\fP function rounds \fI__x\fP to the nearest integer, rounding the halfway cases to the even integer direction. (That is both 1.5 and 2.5 values are rounded to 2). This function is similar to rint() function, but it differs in type of return value and in that an overflow is possible.
.PP
\fBReturns:\fP
.RS 4
The rounded long integer value. If \fI__x\fP is not a finite number or an overflow was, this realization returns the \fCLONG_MIN\fP value (0x80000000). 
.RE
.PP

.SS "long lround (double __x)"
.PP
The \fBlround()\fP function rounds \fI__x\fP to the nearest integer, but rounds halfway cases away from zero (instead of to the nearest even integer). This function is similar to \fBround()\fP function, but it differs in type of return value and in that an overflow is possible.
.PP
\fBReturns:\fP
.RS 4
The rounded long integer value. If \fI__x\fP is not a finite number or an overflow was, this realization returns the \fCLONG_MIN\fP value (0x80000000). 
.RE
.PP

.SS "double modf (double __x, double * __iptr)"
.PP
The \fBmodf()\fP function breaks the argument \fI__x\fP into integral and fractional parts, each of which has the same sign as the argument. It stores the integral part as a double in the object pointed to by \fI__iptr\fP.
.PP
The \fBmodf()\fP function returns the signed fractional part of \fI__x\fP.
.PP
\fBNote:\fP
.RS 4
This implementation skips writing by zero pointer. 
.RE
.PP

.SS "double pow (double __x, double __y)"
.PP
The function \fBpow()\fP returns the value of \fI__x\fP to the exponent \fI__y\fP. 
.SS "double round (double __x)"
.PP
The \fBround()\fP function rounds \fI__x\fP to the nearest integer, but rounds halfway cases away from zero (instead of to the nearest even integer). Overflow is impossible.
.PP
\fBReturns:\fP
.RS 4
The rounded value. If \fI__x\fP is an integral or infinite, \fI__x\fP itself is returned. If \fI__x\fP is \fCNaN\fP, then \fCNaN\fP is returned. 
.RE
.PP

.SS "int signbit (double __x)"
.PP
The \fBsignbit()\fP function returns a nonzero value if the value of \fI__x\fP has its sign bit set. This is not the same as `\fI__x\fP < 0.0', because IEEE 754 floating point allows zero to be signed. The comparison `-0.0 < 0.0' is false, but `signbit (-0.0)' will return a nonzero value.
.PP
\fBNote:\fP
.RS 4
This implementation returns 1 if sign bit is set. 
.RE
.PP

.SS "double sin (double __x)"
.PP
The \fBsin()\fP function returns the sine of \fI__x\fP, measured in radians. 
.SS "double sinh (double __x)"
.PP
The \fBsinh()\fP function returns the hyperbolic sine of \fI__x\fP. 
.SS "double sqrt (double __x)"
.PP
The \fBsqrt()\fP function returns the non-negative square root of \fI__x\fP. 
.SS "double square (double __x)"
.PP
The function \fBsquare()\fP returns \fI__x * __x\fP.
.PP
\fBNote:\fP
.RS 4
This function does not belong to the C standard definition. 
.RE
.PP

.SS "double tan (double __x)"
.PP
The \fBtan()\fP function returns the tangent of \fI__x\fP, measured in radians. 
.SS "double tanh (double __x)"
.PP
The \fBtanh()\fP function returns the hyperbolic tangent of \fI__x\fP. 
.SS "double trunc (double __x)"
.PP
The \fBtrunc()\fP function rounds \fI__x\fP to the nearest integer not larger in absolute value. 
.SH "Author"
.PP 
Generated automatically by Doxygen for avr-libc from the source code.
