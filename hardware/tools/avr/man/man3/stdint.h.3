.TH "stdint.h" 3 "6 Nov 2008" "Version 1.6.4" "avr-libc" \" -*- nroff -*-
.ad l
.nh
.SH NAME
stdint.h \- 
.SH SYNOPSIS
.br
.PP
.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fB__USING_MINT8\fP   0"
.br
.ti -1c
.RI "#define \fB__CONCATenate\fP(left, right)   left ## right"
.br
.ti -1c
.RI "#define \fB__CONCAT\fP(left, right)   __CONCATenate(left, right)"
.br
.in -1c
.PP
.RI "\fBLimits of specified-width integer types\fP"
.br
C++ implementations should define these macros only when __STDC_LIMIT_MACROS is defined before <\fBstdint.h\fP> is included 
.PP
.in +1c
.in +1c
.ti -1c
.RI "#define \fBINT8_MAX\fP   0x7f"
.br
.ti -1c
.RI "#define \fBINT8_MIN\fP   (-INT8_MAX - 1)"
.br
.ti -1c
.RI "#define \fBUINT8_MAX\fP   (__CONCAT(INT8_MAX, U) * 2U + 1U)"
.br
.ti -1c
.RI "#define \fBINT16_MAX\fP   0x7fff"
.br
.ti -1c
.RI "#define \fBINT16_MIN\fP   (-INT16_MAX - 1)"
.br
.ti -1c
.RI "#define \fBUINT16_MAX\fP   (__CONCAT(INT16_MAX, U) * 2U + 1U)"
.br
.ti -1c
.RI "#define \fBINT32_MAX\fP   0x7fffffffL"
.br
.ti -1c
.RI "#define \fBINT32_MIN\fP   (-INT32_MAX - 1L)"
.br
.ti -1c
.RI "#define \fBUINT32_MAX\fP   (__CONCAT(INT32_MAX, U) * 2UL + 1UL)"
.br
.ti -1c
.RI "#define \fBINT64_MAX\fP   0x7fffffffffffffffLL"
.br
.ti -1c
.RI "#define \fBINT64_MIN\fP   (-INT64_MAX - 1LL)"
.br
.ti -1c
.RI "#define \fBUINT64_MAX\fP   (__CONCAT(INT64_MAX, U) * 2ULL + 1ULL)"
.br
.in -1c
.in -1c
.PP
.RI "\fBLimits of minimum-width integer types\fP"
.br

.PP
.in +1c
.in +1c
.ti -1c
.RI "#define \fBINT_LEAST8_MAX\fP   INT8_MAX"
.br
.ti -1c
.RI "#define \fBINT_LEAST8_MIN\fP   INT8_MIN"
.br
.ti -1c
.RI "#define \fBUINT_LEAST8_MAX\fP   UINT8_MAX"
.br
.ti -1c
.RI "#define \fBINT_LEAST16_MAX\fP   INT16_MAX"
.br
.ti -1c
.RI "#define \fBINT_LEAST16_MIN\fP   INT16_MIN"
.br
.ti -1c
.RI "#define \fBUINT_LEAST16_MAX\fP   UINT16_MAX"
.br
.ti -1c
.RI "#define \fBINT_LEAST32_MAX\fP   INT32_MAX"
.br
.ti -1c
.RI "#define \fBINT_LEAST32_MIN\fP   INT32_MIN"
.br
.ti -1c
.RI "#define \fBUINT_LEAST32_MAX\fP   UINT32_MAX"
.br
.ti -1c
.RI "#define \fBINT_LEAST64_MAX\fP   INT64_MAX"
.br
.ti -1c
.RI "#define \fBINT_LEAST64_MIN\fP   INT64_MIN"
.br
.ti -1c
.RI "#define \fBUINT_LEAST64_MAX\fP   UINT64_MAX"
.br
.in -1c
.in -1c
.PP
.RI "\fBLimits of fastest minimum-width integer types\fP"
.br

.PP
.in +1c
.in +1c
.ti -1c
.RI "#define \fBINT_FAST8_MAX\fP   INT8_MAX"
.br
.ti -1c
.RI "#define \fBINT_FAST8_MIN\fP   INT8_MIN"
.br
.ti -1c
.RI "#define \fBUINT_FAST8_MAX\fP   UINT8_MAX"
.br
.ti -1c
.RI "#define \fBINT_FAST16_MAX\fP   INT16_MAX"
.br
.ti -1c
.RI "#define \fBINT_FAST16_MIN\fP   INT16_MIN"
.br
.ti -1c
.RI "#define \fBUINT_FAST16_MAX\fP   UINT16_MAX"
.br
.ti -1c
.RI "#define \fBINT_FAST32_MAX\fP   INT32_MAX"
.br
.ti -1c
.RI "#define \fBINT_FAST32_MIN\fP   INT32_MIN"
.br
.ti -1c
.RI "#define \fBUINT_FAST32_MAX\fP   UINT32_MAX"
.br
.ti -1c
.RI "#define \fBINT_FAST64_MAX\fP   INT64_MAX"
.br
.ti -1c
.RI "#define \fBINT_FAST64_MIN\fP   INT64_MIN"
.br
.ti -1c
.RI "#define \fBUINT_FAST64_MAX\fP   UINT64_MAX"
.br
.in -1c
.in -1c
.PP
.RI "\fBLimits of integer types capable of holding object pointers\fP"
.br

.PP
.in +1c
.in +1c
.ti -1c
.RI "#define \fBINTPTR_MAX\fP   INT16_MAX"
.br
.ti -1c
.RI "#define \fBINTPTR_MIN\fP   INT16_MIN"
.br
.ti -1c
.RI "#define \fBUINTPTR_MAX\fP   UINT16_MAX"
.br
.in -1c
.in -1c
.PP
.RI "\fBLimits of greatest-width integer types\fP"
.br

.PP
.in +1c
.in +1c
.ti -1c
.RI "#define \fBINTMAX_MAX\fP   INT64_MAX"
.br
.ti -1c
.RI "#define \fBINTMAX_MIN\fP   INT64_MIN"
.br
.ti -1c
.RI "#define \fBUINTMAX_MAX\fP   UINT64_MAX"
.br
.in -1c
.in -1c
.PP
.RI "\fBLimits of other integer types\fP"
.br
C++ implementations should define these macros only when __STDC_LIMIT_MACROS is defined before <\fBstdint.h\fP> is included 
.PP
.in +1c
.in +1c
.ti -1c
.RI "#define \fBPTRDIFF_MAX\fP   INT16_MAX"
.br
.ti -1c
.RI "#define \fBPTRDIFF_MIN\fP   INT16_MIN"
.br
.ti -1c
.RI "#define \fBSIG_ATOMIC_MAX\fP   INT8_MAX"
.br
.ti -1c
.RI "#define \fBSIG_ATOMIC_MIN\fP   INT8_MIN"
.br
.ti -1c
.RI "#define \fBSIZE_MAX\fP   (__CONCAT(INT16_MAX, U))"
.br
.in -1c
.in -1c
.PP
.RI "\fBMacros for integer constants\fP"
.br
C++ implementations should define these macros only when __STDC_CONSTANT_MACROS is defined before <\fBstdint.h\fP> is included.
.PP
These definitions are valid for integer constants without suffix and for macros defined as integer constant without suffix 
.PP
.in +1c
.in +1c
.ti -1c
.RI "#define \fBINT8_C\fP(value)   ((\fBint8_t\fP) value)"
.br
.ti -1c
.RI "#define \fBUINT8_C\fP(value)   ((\fBuint8_t\fP) __CONCAT(value, U))"
.br
.ti -1c
.RI "#define \fBINT16_C\fP(value)   value"
.br
.ti -1c
.RI "#define \fBUINT16_C\fP(value)   __CONCAT(value, U)"
.br
.ti -1c
.RI "#define \fBINT32_C\fP(value)   __CONCAT(value, L)"
.br
.ti -1c
.RI "#define \fBUINT32_C\fP(value)   __CONCAT(value, UL)"
.br
.ti -1c
.RI "#define \fBINT64_C\fP(value)   __CONCAT(value, LL)"
.br
.ti -1c
.RI "#define \fBUINT64_C\fP(value)   __CONCAT(value, ULL)"
.br
.ti -1c
.RI "#define \fBINTMAX_C\fP(value)   __CONCAT(value, LL)"
.br
.ti -1c
.RI "#define \fBUINTMAX_C\fP(value)   __CONCAT(value, ULL)"
.br
.in -1c
.in -1c
.SS "Typedefs"

.PP
.RI "\fBExact-width integer types\fP"
.br
Integer types having exactly the specified width 
.PP
.in +1c
.in +1c
.ti -1c
.RI "typedef signed char \fBint8_t\fP"
.br
.ti -1c
.RI "typedef unsigned char \fBuint8_t\fP"
.br
.ti -1c
.RI "typedef signed int \fBint16_t\fP"
.br
.ti -1c
.RI "typedef unsigned int \fBuint16_t\fP"
.br
.ti -1c
.RI "typedef signed long int \fBint32_t\fP"
.br
.ti -1c
.RI "typedef unsigned long int \fBuint32_t\fP"
.br
.ti -1c
.RI "typedef signed long long int \fBint64_t\fP"
.br
.ti -1c
.RI "typedef unsigned long long int \fBuint64_t\fP"
.br
.in -1c
.in -1c
.PP
.RI "\fBInteger types capable of holding object pointers\fP"
.br
These allow you to declare variables of the same size as a pointer. 
.PP
.in +1c
.in +1c
.ti -1c
.RI "typedef \fBint16_t\fP \fBintptr_t\fP"
.br
.ti -1c
.RI "typedef \fBuint16_t\fP \fBuintptr_t\fP"
.br
.in -1c
.in -1c
.PP
.RI "\fBMinimum-width integer types\fP"
.br
Integer types having at least the specified width 
.PP
.in +1c
.in +1c
.ti -1c
.RI "typedef \fBint8_t\fP \fBint_least8_t\fP"
.br
.ti -1c
.RI "typedef \fBuint8_t\fP \fBuint_least8_t\fP"
.br
.ti -1c
.RI "typedef \fBint16_t\fP \fBint_least16_t\fP"
.br
.ti -1c
.RI "typedef \fBuint16_t\fP \fBuint_least16_t\fP"
.br
.ti -1c
.RI "typedef \fBint32_t\fP \fBint_least32_t\fP"
.br
.ti -1c
.RI "typedef \fBuint32_t\fP \fBuint_least32_t\fP"
.br
.ti -1c
.RI "typedef \fBint64_t\fP \fBint_least64_t\fP"
.br
.ti -1c
.RI "typedef \fBuint64_t\fP \fBuint_least64_t\fP"
.br
.in -1c
.in -1c
.PP
.RI "\fBFastest minimum-width integer types\fP"
.br
Integer types being usually fastest having at least the specified width 
.PP
.in +1c
.in +1c
.ti -1c
.RI "typedef \fBint8_t\fP \fBint_fast8_t\fP"
.br
.ti -1c
.RI "typedef \fBuint8_t\fP \fBuint_fast8_t\fP"
.br
.ti -1c
.RI "typedef \fBint16_t\fP \fBint_fast16_t\fP"
.br
.ti -1c
.RI "typedef \fBuint16_t\fP \fBuint_fast16_t\fP"
.br
.ti -1c
.RI "typedef \fBint32_t\fP \fBint_fast32_t\fP"
.br
.ti -1c
.RI "typedef \fBuint32_t\fP \fBuint_fast32_t\fP"
.br
.ti -1c
.RI "typedef \fBint64_t\fP \fBint_fast64_t\fP"
.br
.ti -1c
.RI "typedef \fBuint64_t\fP \fBuint_fast64_t\fP"
.br
.in -1c
.in -1c
.PP
.RI "\fBGreatest-width integer types\fP"
.br
Types designating integer data capable of representing any value of any integer type in the corresponding signed or unsigned category 
.PP
.in +1c
.in +1c
.ti -1c
.RI "typedef \fBint64_t\fP \fBintmax_t\fP"
.br
.ti -1c
.RI "typedef \fBuint64_t\fP \fBuintmax_t\fP"
.br
.in -1c
.in -1c
.SH "Detailed Description"
.PP 

.SH "Author"
.PP 
Generated automatically by Doxygen for avr-libc from the source code.
