.TH "pgmspace.h" 3 "6 Nov 2008" "Version 1.6.4" "avr-libc" \" -*- nroff -*-
.ad l
.nh
.SH NAME
pgmspace.h \- 
.SH SYNOPSIS
.br
.PP
.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fB__PGMSPACE_H_\fP   1"
.br
.ti -1c
.RI "#define \fB__need_size_t\fP"
.br
.ti -1c
.RI "#define \fB__ATTR_PROGMEM__\fP   __attribute__((__progmem__))"
.br
.ti -1c
.RI "#define \fB__ATTR_PURE__\fP   __attribute__((__pure__))"
.br
.ti -1c
.RI "#define \fBPROGMEM\fP   __ATTR_PROGMEM__"
.br
.ti -1c
.RI "#define \fBPSTR\fP(s)   ((const PROGMEM char *)(s))"
.br
.ti -1c
.RI "#define \fB__LPM_classic__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__LPM_enhanced__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__LPM_word_classic__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__LPM_word_enhanced__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__LPM_dword_classic__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__LPM_dword_enhanced__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__LPM_float_classic__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__LPM_float_enhanced__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__LPM\fP(addr)   __LPM_classic__(addr)"
.br
.ti -1c
.RI "#define \fB__LPM_word\fP(addr)   __LPM_word_classic__(addr)"
.br
.ti -1c
.RI "#define \fB__LPM_dword\fP(addr)   __LPM_dword_classic__(addr)"
.br
.ti -1c
.RI "#define \fB__LPM_float\fP(addr)   __LPM_float_classic__(addr)"
.br
.ti -1c
.RI "#define \fBpgm_read_byte_near\fP(address_short)   __LPM((\fBuint16_t\fP)(address_short))"
.br
.ti -1c
.RI "#define \fBpgm_read_word_near\fP(address_short)   __LPM_word((\fBuint16_t\fP)(address_short))"
.br
.ti -1c
.RI "#define \fBpgm_read_dword_near\fP(address_short)   __LPM_dword((\fBuint16_t\fP)(address_short))"
.br
.ti -1c
.RI "#define \fBpgm_read_float_near\fP(address_short)   __LPM_float((\fBuint16_t\fP)(address_short))"
.br
.ti -1c
.RI "#define \fB__ELPM_classic__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__ELPM_enhanced__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__ELPM_word_classic__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__ELPM_word_enhanced__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__ELPM_dword_classic__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__ELPM_dword_enhanced__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__ELPM_float_classic__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__ELPM_float_enhanced__\fP(addr)"
.br
.ti -1c
.RI "#define \fB__ELPM\fP(addr)   __ELPM_classic__(addr)"
.br
.ti -1c
.RI "#define \fB__ELPM_word\fP(addr)   __ELPM_word_classic__(addr)"
.br
.ti -1c
.RI "#define \fB__ELPM_dword\fP(addr)   __ELPM_dword_classic__(addr)"
.br
.ti -1c
.RI "#define \fB__ELPM_float\fP(addr)   __ELPM_float_classic__(addr)"
.br
.ti -1c
.RI "#define \fBpgm_read_byte_far\fP(address_long)   __ELPM((\fBuint32_t\fP)(address_long))"
.br
.ti -1c
.RI "#define \fBpgm_read_word_far\fP(address_long)   __ELPM_word((\fBuint32_t\fP)(address_long))"
.br
.ti -1c
.RI "#define \fBpgm_read_dword_far\fP(address_long)   __ELPM_dword((\fBuint32_t\fP)(address_long))"
.br
.ti -1c
.RI "#define \fBpgm_read_float_far\fP(address_long)   __ELPM_float((\fBuint32_t\fP)(address_long))"
.br
.ti -1c
.RI "#define \fBpgm_read_byte\fP(address_short)   pgm_read_byte_near(address_short)"
.br
.ti -1c
.RI "#define \fBpgm_read_word\fP(address_short)   pgm_read_word_near(address_short)"
.br
.ti -1c
.RI "#define \fBpgm_read_dword\fP(address_short)   pgm_read_dword_near(address_short)"
.br
.ti -1c
.RI "#define \fBpgm_read_float\fP(address_short)   pgm_read_float_near(address_short)"
.br
.ti -1c
.RI "#define \fBPGM_P\fP   const \fBprog_char\fP *"
.br
.ti -1c
.RI "#define \fBPGM_VOID_P\fP   const \fBprog_void\fP *"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef void PROGMEM \fBprog_void\fP"
.br
.ti -1c
.RI "typedef char PROGMEM \fBprog_char\fP"
.br
.ti -1c
.RI "typedef unsigned char PROGMEM \fBprog_uchar\fP"
.br
.ti -1c
.RI "typedef \fBint8_t\fP PROGMEM \fBprog_int8_t\fP"
.br
.ti -1c
.RI "typedef \fBuint8_t\fP PROGMEM \fBprog_uint8_t\fP"
.br
.ti -1c
.RI "typedef \fBint16_t\fP PROGMEM \fBprog_int16_t\fP"
.br
.ti -1c
.RI "typedef \fBuint16_t\fP PROGMEM \fBprog_uint16_t\fP"
.br
.ti -1c
.RI "typedef \fBint32_t\fP PROGMEM \fBprog_int32_t\fP"
.br
.ti -1c
.RI "typedef \fBuint32_t\fP PROGMEM \fBprog_uint32_t\fP"
.br
.ti -1c
.RI "typedef \fBint64_t\fP PROGMEM \fBprog_int64_t\fP"
.br
.ti -1c
.RI "typedef \fBuint64_t\fP PROGMEM \fBprog_uint64_t\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "PGM_VOID_P \fBmemchr_P\fP (PGM_VOID_P, int __val, size_t __len)"
.br
.ti -1c
.RI "int \fBmemcmp_P\fP (const void *, PGM_VOID_P, size_t) __ATTR_PURE__"
.br
.ti -1c
.RI "void * \fBmemcpy_P\fP (void *, PGM_VOID_P, size_t)"
.br
.ti -1c
.RI "void * \fBmemmem_P\fP (const void *, size_t, PGM_VOID_P, size_t) __ATTR_PURE__"
.br
.ti -1c
.RI "PGM_VOID_P \fBmemrchr_P\fP (PGM_VOID_P, int __val, size_t __len)"
.br
.ti -1c
.RI "char * \fBstrcat_P\fP (char *, PGM_P)"
.br
.ti -1c
.RI "PGM_P \fBstrchr_P\fP (PGM_P, int __val)"
.br
.ti -1c
.RI "PGM_P \fBstrchrnul_P\fP (PGM_P, int __val)"
.br
.ti -1c
.RI "int \fBstrcmp_P\fP (const char *, PGM_P) __ATTR_PURE__"
.br
.ti -1c
.RI "char * \fBstrcpy_P\fP (char *, PGM_P)"
.br
.ti -1c
.RI "int \fBstrcasecmp_P\fP (const char *, PGM_P) __ATTR_PURE__"
.br
.ti -1c
.RI "char * \fBstrcasestr_P\fP (const char *, PGM_P) __ATTR_PURE__"
.br
.ti -1c
.RI "size_t \fBstrcspn_P\fP (const char *__s, PGM_P __reject) __ATTR_PURE__"
.br
.ti -1c
.RI "size_t \fBstrlcat_P\fP (char *, PGM_P, size_t)"
.br
.ti -1c
.RI "size_t \fBstrlcpy_P\fP (char *, PGM_P, size_t)"
.br
.ti -1c
.RI "size_t \fBstrlen_P\fP (PGM_P)"
.br
.ti -1c
.RI "size_t \fBstrnlen_P\fP (PGM_P, size_t)"
.br
.ti -1c
.RI "int \fBstrncmp_P\fP (const char *, PGM_P, size_t) __ATTR_PURE__"
.br
.ti -1c
.RI "int \fBstrncasecmp_P\fP (const char *, PGM_P, size_t) __ATTR_PURE__"
.br
.ti -1c
.RI "char * \fBstrncat_P\fP (char *, PGM_P, size_t)"
.br
.ti -1c
.RI "char * \fBstrncpy_P\fP (char *, PGM_P, size_t)"
.br
.ti -1c
.RI "char * \fBstrpbrk_P\fP (const char *__s, PGM_P __accept) __ATTR_PURE__"
.br
.ti -1c
.RI "PGM_P \fBstrrchr_P\fP (PGM_P, int __val)"
.br
.ti -1c
.RI "char * \fBstrsep_P\fP (char **__sp, PGM_P __delim)"
.br
.ti -1c
.RI "size_t \fBstrspn_P\fP (const char *__s, PGM_P __accept) __ATTR_PURE__"
.br
.ti -1c
.RI "char * \fBstrstr_P\fP (const char *, PGM_P) __ATTR_PURE__"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SH "Define Documentation"
.PP 
.SS "#define __ELPM_classic__(addr)"
.PP
\fBValue:\fP
.PP
.nf
(__extension__({                    \
    uint32_t __addr32 = (uint32_t)(addr); \
    uint8_t __result;               \
    __asm__                         \
    (                               \
        'out %2, %C1' '\n\t'        \
        'mov r31, %B1' '\n\t'       \
        'mov r30, %A1' '\n\t'       \
        'elpm' '\n\t'               \
        'mov %0, r0' '\n\t'         \
        : '=r' (__result)           \
        : 'r' (__addr32),           \
          'I' (_SFR_IO_ADDR(RAMPZ)) \
        : 'r0', 'r30', 'r31'        \
    );                              \
    __result;                       \
}))
.fi
.SS "#define __ELPM_dword_enhanced__(addr)"
.PP
\fBValue:\fP
.PP
.nf
(__extension__({                          \
    uint32_t __addr32 = (uint32_t)(addr); \
    uint32_t __result;                    \
    __asm__                               \
    (                                     \
        'out %2, %C1'   '\n\t'            \
        'movw r30, %1'  '\n\t'            \
        'elpm %A0, Z+'  '\n\t'            \
        'elpm %B0, Z+'  '\n\t'            \
        'elpm %C0, Z+'  '\n\t'            \
        'elpm %D0, Z'   '\n\t'            \
        : '=r' (__result)                 \
        : 'r' (__addr32),                 \
          'I' (_SFR_IO_ADDR(RAMPZ))       \
        : 'r30', 'r31'                    \
    );                                    \
    __result;                             \
}))
.fi
.SS "#define __ELPM_enhanced__(addr)"
.PP
\fBValue:\fP
.PP
.nf
(__extension__({                    \
    uint32_t __addr32 = (uint32_t)(addr); \
    uint8_t __result;               \
    __asm__                         \
    (                               \
        'out %2, %C1' '\n\t'        \
        'movw r30, %1' '\n\t'       \
        'elpm %0, Z+' '\n\t'        \
        : '=r' (__result)           \
        : 'r' (__addr32),           \
          'I' (_SFR_IO_ADDR(RAMPZ)) \
        : 'r30', 'r31'              \
    );                              \
    __result;                       \
}))
.fi
.SS "#define __ELPM_float_enhanced__(addr)"
.PP
\fBValue:\fP
.PP
.nf
(__extension__({                          \
    uint32_t __addr32 = (uint32_t)(addr); \
    float __result;                       \
    __asm__                               \
    (                                     \
        'out %2, %C1'   '\n\t'            \
        'movw r30, %1'  '\n\t'            \
        'elpm %A0, Z+'  '\n\t'            \
        'elpm %B0, Z+'  '\n\t'            \
        'elpm %C0, Z+'  '\n\t'            \
        'elpm %D0, Z'   '\n\t'            \
        : '=r' (__result)                 \
        : 'r' (__addr32),                 \
          'I' (_SFR_IO_ADDR(RAMPZ))       \
        : 'r30', 'r31'                    \
    );                                    \
    __result;                             \
}))
.fi
.SS "#define __ELPM_word_classic__(addr)"
.PP
\fBValue:\fP
.PP
.nf
(__extension__({                        \
    uint32_t __addr32 = (uint32_t)(addr); \
    uint16_t __result;                  \
    __asm__                             \
    (                                   \
        'out %2, %C1'   '\n\t'          \
        'mov r31, %B1'  '\n\t'          \
        'mov r30, %A1'  '\n\t'          \
        'elpm'          '\n\t'          \
        'mov %A0, r0'   '\n\t'          \
        'in r0, %2'     '\n\t'          \
        'adiw r30, 1'   '\n\t'          \
        'adc r0, __zero_reg__' '\n\t'   \
        'out %2, r0'    '\n\t'          \
        'elpm'          '\n\t'          \
        'mov %B0, r0'   '\n\t'          \
        : '=r' (__result)               \
        : 'r' (__addr32),               \
          'I' (_SFR_IO_ADDR(RAMPZ))     \
        : 'r0', 'r30', 'r31'            \
    );                                  \
    __result;                           \
}))
.fi
.SS "#define __ELPM_word_enhanced__(addr)"
.PP
\fBValue:\fP
.PP
.nf
(__extension__({                        \
    uint32_t __addr32 = (uint32_t)(addr); \
    uint16_t __result;                  \
    __asm__                             \
    (                                   \
        'out %2, %C1'   '\n\t'          \
        'movw r30, %1'  '\n\t'          \
        'elpm %A0, Z+'  '\n\t'          \
        'elpm %B0, Z'   '\n\t'          \
        : '=r' (__result)               \
        : 'r' (__addr32),               \
          'I' (_SFR_IO_ADDR(RAMPZ))     \
        : 'r30', 'r31'                  \
    );                                  \
    __result;                           \
}))
.fi
.SS "#define __LPM_classic__(addr)"
.PP
\fBValue:\fP
.PP
.nf
(__extension__({                \
    uint16_t __addr16 = (uint16_t)(addr); \
    uint8_t __result;           \
    __asm__                     \
    (                           \
        'lpm' '\n\t'            \
        'mov %0, r0' '\n\t'     \
        : '=r' (__result)       \
        : 'z' (__addr16)        \
        : 'r0'                  \
    );                          \
    __result;                   \
}))
.fi
.SS "#define __LPM_dword_classic__(addr)"
.PP
\fBValue:\fP
.PP
.nf
(__extension__({                            \
    uint16_t __addr16 = (uint16_t)(addr);   \
    uint32_t __result;                      \
    __asm__                                 \
    (                                       \
        'lpm'           '\n\t'              \
        'mov %A0, r0'   '\n\t'              \
        'adiw r30, 1'   '\n\t'              \
        'lpm'           '\n\t'              \
        'mov %B0, r0'   '\n\t'              \
        'adiw r30, 1'   '\n\t'              \
        'lpm'           '\n\t'              \
        'mov %C0, r0'   '\n\t'              \
        'adiw r30, 1'   '\n\t'              \
        'lpm'           '\n\t'              \
        'mov %D0, r0'   '\n\t'              \
        : '=r' (__result), '=z' (__addr16)  \
        : '1' (__addr16)                    \
        : 'r0'                              \
    );                                      \
    __result;                               \
}))
.fi
.SS "#define __LPM_dword_enhanced__(addr)"
.PP
\fBValue:\fP
.PP
.nf
(__extension__({                            \
    uint16_t __addr16 = (uint16_t)(addr);   \
    uint32_t __result;                      \
    __asm__                                 \
    (                                       \
        'lpm %A0, Z+'   '\n\t'              \
        'lpm %B0, Z+'   '\n\t'              \
        'lpm %C0, Z+'   '\n\t'              \
        'lpm %D0, Z'    '\n\t'              \
        : '=r' (__result), '=z' (__addr16)  \
        : '1' (__addr16)                    \
    );                                      \
    __result;                               \
}))
.fi
.SS "#define __LPM_enhanced__(addr)"
.PP
\fBValue:\fP
.PP
.nf
(__extension__({                \
    uint16_t __addr16 = (uint16_t)(addr); \
    uint8_t __result;           \
    __asm__                     \
    (                           \
        'lpm %0, Z' '\n\t'      \
        : '=r' (__result)       \
        : 'z' (__addr16)        \
    );                          \
    __result;                   \
}))
.fi
.SS "#define __LPM_float_classic__(addr)"
.PP
\fBValue:\fP
.PP
.nf
(__extension__({                            \
    uint16_t __addr16 = (uint16_t)(addr);   \
    float __result;                         \
    __asm__                                 \
    (                                       \
        'lpm'           '\n\t'              \
        'mov %A0, r0'   '\n\t'              \
        'adiw r30, 1'   '\n\t'              \
        'lpm'           '\n\t'              \
        'mov %B0, r0'   '\n\t'              \
        'adiw r30, 1'   '\n\t'              \
        'lpm'           '\n\t'              \
        'mov %C0, r0'   '\n\t'              \
        'adiw r30, 1'   '\n\t'              \
        'lpm'           '\n\t'              \
        'mov %D0, r0'   '\n\t'              \
        : '=r' (__result), '=z' (__addr16)  \
        : '1' (__addr16)                    \
        : 'r0'                              \
    );                                      \
    __result;                               \
}))
.fi
.SS "#define __LPM_float_enhanced__(addr)"
.PP
\fBValue:\fP
.PP
.nf
(__extension__({                            \
    uint16_t __addr16 = (uint16_t)(addr);   \
    float __result;                         \
    __asm__                                 \
    (                                       \
        'lpm %A0, Z+'   '\n\t'              \
        'lpm %B0, Z+'   '\n\t'              \
        'lpm %C0, Z+'   '\n\t'              \
        'lpm %D0, Z'    '\n\t'              \
        : '=r' (__result), '=z' (__addr16)  \
        : '1' (__addr16)                    \
    );                                      \
    __result;                               \
}))
.fi
.SS "#define __LPM_word_classic__(addr)"
.PP
\fBValue:\fP
.PP
.nf
(__extension__({                            \
    uint16_t __addr16 = (uint16_t)(addr);   \
    uint16_t __result;                      \
    __asm__                                 \
    (                                       \
        'lpm'           '\n\t'              \
        'mov %A0, r0'   '\n\t'              \
        'adiw r30, 1'   '\n\t'              \
        'lpm'           '\n\t'              \
        'mov %B0, r0'   '\n\t'              \
        : '=r' (__result), '=z' (__addr16)  \
        : '1' (__addr16)                    \
        : 'r0'                              \
    );                                      \
    __result;                               \
}))
.fi
.SS "#define __LPM_word_enhanced__(addr)"
.PP
\fBValue:\fP
.PP
.nf
(__extension__({                            \
    uint16_t __addr16 = (uint16_t)(addr);   \
    uint16_t __result;                      \
    __asm__                                 \
    (                                       \
        'lpm %A0, Z+'   '\n\t'              \
        'lpm %B0, Z'    '\n\t'              \
        : '=r' (__result), '=z' (__addr16)  \
        : '1' (__addr16)                    \
    );                                      \
    __result;                               \
}))
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for avr-libc from the source code.
