<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
    <title>avr-libc: &lt;avr/interrupt.h&gt;: Interrupts</title>
    <link href="dox.css" rel="stylesheet" type="text/css">
  </head>
<body>
<center>
<table width="80%">
  <tr>
    <td align="left"><a href="http://www.nongnu.org/avr-libc/">AVR Libc Home Page</a></td>
    <td align="center" colspan=4><img src="avrs.png" alt="AVRs" align="middle" border="0"></td>
    <td align="right"><a href="https://savannah.nongnu.org/projects/avr-libc/">AVR Libc Development Pages</a></td>
  </tr>
  <tr>
    <td align="center" width="13%"><a href="index.html">Main Page</a></td>
    <td align="center" width="13%"><a href="pages.html">User Manual</a></td>
    <td align="center" width="13%"><a href="modules.html">Library Reference</a></td>
    <td align="center" width="13%"><a href="FAQ.html">FAQ</a></td>
    <td align="center" width="13%"><a href="globals.html">Alphabetical Index</a></td>
    <td align="center" width="13%"><a href="group__demos.html">Example Projects</a></td>
  </tr>
</table>
</center>
<hr width="80%">
<!-- Generated by Doxygen 1.5.7 -->
<div class="contents">
<h1>&lt;avr/interrupt.h&gt;: Interrupts</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This discussion of interrupts was originally taken from Rich Neswold's document. See <a class="el" href="acks.html">Acknowledgments</a>.</dd></dl>
<h3>Introduction to avr-libc's interrupt handling</h3>
<p>
It's nearly impossible to find compilers that agree on how to handle interrupt code. Since the C language tries to stay away from machine dependent details, each compiler writer is forced to design their method of support.<p>
In the AVR-GCC environment, the vector table is predefined to point to interrupt routines with predetermined names. By using the appropriate name, your routine will be called when the corresponding interrupt occurs. The device library provides a set of default interrupt routines, which will get used if you don't define your own.<p>
Patching into the vector table is only one part of the problem. The compiler uses, by convention, a set of registers when it's normally executing compiler-generated code. It's important that these registers, as well as the status register, get saved and restored. The extra code needed to do this is enabled by tagging the interrupt function with <code>__attribute__((signal))</code>.<p>
These details seem to make interrupt routines a little messy, but all these details are handled by the Interrupt API. An interrupt routine is defined with <a class="el" href="group__avr__interrupts.html#gd28590624d422cdf30d626e0a506255f">ISR()</a>. This macro register and mark the routine as an interrupt handler for the specified peripheral. The following is an example definition of a handler for the ADC interrupt.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="interrupt_8h.html">avr/interrupt.h</a>&gt;</span>

<a class="code" href="group__avr__interrupts.html#gd28590624d422cdf30d626e0a506255f">ISR</a>(ADC_vect)
{
    <span class="comment">// user code here</span>
}
</pre></div><p>
Refer to the chapter explaining <a class="el" href="assembler.html#ass_isr">assembler programming</a> for an explanation about interrupt routines written solely in assembler language.<p>
<h3>Catch-all interrupt vector</h3>
<p>
If an unexpected interrupt occurs (interrupt is enabled and no handler is installed, which usually indicates a bug), then the default action is to reset the device by jumping to the reset vector. You can override this by supplying a function named <code>BADISR_vect</code> which should be defined with <a class="el" href="group__avr__interrupts.html#gd28590624d422cdf30d626e0a506255f">ISR()</a> as such. (The name BADISR_vect is actually an alias for __vector_default. The latter must be used inside assembly code in case &lt;<a class="el" href="interrupt_8h.html">avr/interrupt.h</a>&gt; is not included.)<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="interrupt_8h.html">avr/interrupt.h</a>&gt;</span>

<a class="code" href="group__avr__interrupts.html#gd28590624d422cdf30d626e0a506255f">ISR</a>(<a class="code" href="group__avr__interrupts.html#g1f6459a85cda682b2163a20af03ac744">BADISR_vect</a>)
{
    <span class="comment">// user code here</span>
}
</pre></div><p>
<h3>Nested interrupts</h3>
<p>
The AVR hardware clears the global interrupt flag in SREG before entering an interrupt vector. Thus, normally interrupts will remain disabled inside the handler until the handler exits, where the RETI instruction (that is emitted by the compiler as part of the normal function epilogue for an interrupt handler) will eventually re-enable further interrupts. For that reason, interrupt handlers normally do not nest. For most interrupt handlers, this is the desired behaviour, for some it is even required in order to prevent infinitely recursive interrupts (like UART interrupts, or level-triggered external interrupts). In rare circumstances though it might be desired to re-enable the global interrupt flag as early as possible in the interrupt handler, in order to not defer any other interrupt more than absolutely needed. This could be done using an <a class="el" href="group__avr__interrupts.html#gad5ebd34cb344c26ac87594f79b06b73">sei()</a> instruction right at the beginning of the interrupt handler, but this still leaves few instructions inside the compiler-generated function prologue to run with global interrupts disabled. The compiler can be instructed to insert an SEI instruction right at the beginning of an interrupt handler by declaring the handler the following way:<p>
<a class="anchor" name="attr_interrupt"></a> <div class="fragment"><pre class="fragment"><a class="code" href="group__avr__interrupts.html#gd28590624d422cdf30d626e0a506255f">ISR</a>(XXX_vect, <a class="code" href="group__avr__interrupts.html#g44569cb914d2aaf8fbb436f8f7c4ca68">ISR_NOBLOCK</a>)
{
  ...
}
</pre></div><p>
where <code>XXX_vect</code> is the name of a valid interrupt vector for the MCU type in question, as explained below.<p>
<h3>Two vectors sharing the same code</h3>
<p>
In some circumstances, the actions to be taken upon two different interrupts might be completely identical so a single implementation for the ISR would suffice. For example, pin-change interrupts arriving from two different ports could logically signal an event that is independent from the actual port (and thus interrupt vector) where it happened. Sharing interrupt vector code can be accomplished using the <a class="el" href="group__avr__interrupts.html#ga87c0c624b62f40a17539be6946c3e26">ISR_ALIASOF()</a> attribute to the ISR macro:<p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__avr__interrupts.html#gd28590624d422cdf30d626e0a506255f">ISR</a>(PCINT0_vect)
{
  ...
  <span class="comment">// Code to handle the event.</span>
}

<a class="code" href="group__avr__interrupts.html#gd28590624d422cdf30d626e0a506255f">ISR</a>(PCINT1_vect, <a class="code" href="group__avr__interrupts.html#ga87c0c624b62f40a17539be6946c3e26">ISR_ALIASOF</a>(PCINT0_vect));
</pre></div><p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>There is no body to the aliased ISR.</dd></dl>
Note that the <a class="el" href="group__avr__interrupts.html#ga87c0c624b62f40a17539be6946c3e26">ISR_ALIASOF()</a> feature requires GCC 4.2 or above (or a patched version of GCC 4.1.x). See the documentation of the <a class="el" href="group__avr__interrupts.html#gde46eb4e42cc9d56c19b1f91448f1b76">ISR_ALIAS()</a> macro for an implementation which is less elegant but could be applied to all compiler versions.<p>
<h3>Empty interrupt service routines</h3>
<p>
In rare circumstances, in interrupt vector does not need any code to be implemented at all. The vector must be declared anyway, so when the interrupt triggers it won't execute the BADISR_vect code (which by default restarts the application).<p>
This could for example be the case for interrupts that are solely enabled for the purpose of getting the controller out of sleep_mode().<p>
A handler for such an interrupt vector can be declared using the <a class="el" href="group__avr__interrupts.html#g751c22101f7e8f2fbe792c64a81f8dba">EMPTY_INTERRUPT()</a> macro:<p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__avr__interrupts.html#g751c22101f7e8f2fbe792c64a81f8dba">EMPTY_INTERRUPT</a>(ADC_vect);
</pre></div><p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>There is no body to this macro.</dd></dl>
<h3>Manually defined ISRs</h3>
<p>
In some circumstances, the compiler-generated prologue and epilogue of the ISR might not be optimal for the job, and a manually defined ISR could be considered particularly to speedup the interrupt handling.<p>
One solution to this could be to implement the entire ISR as manual assembly code in a separate (assembly) file. See <a class="el" href="group__asmdemo.html">Combining C and assembly source files</a> for an example of how to implement it that way.<p>
Another solution is to still implement the ISR in C language but take over the compiler's job of generating the prologue and epilogue. This can be done using the ISR_NAKED attribute to the <a class="el" href="group__avr__interrupts.html#gd28590624d422cdf30d626e0a506255f">ISR()</a> macro. Note that the compiler does not generate <em>anything</em> as prologue or epilogue, so the final <a class="el" href="group__avr__interrupts.html#g3b991e8168db8fc866e31f9a6d10533b">reti()</a> must be provided by the actual implementation. SREG must be manually saved if the ISR code modifies it, and the compiler-implied assumption of <code>__zero_reg__</code> always being 0 could be wrong (e. g. when interrupting right after of a MUL instruction).<p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__avr__interrupts.html#gd28590624d422cdf30d626e0a506255f">ISR</a>(TIMER1_OVF_vect, <a class="code" href="group__avr__interrupts.html#g8b4c7e44627db0a60d676213add42d64">ISR_NAKED</a>)
{
  PORTB |= <a class="code" href="group__avr__sfr.html#g11643f271076024c395a93800b3d9546">_BV</a>(0);  <span class="comment">// results in SBI which does not affect SREG</span>
  <a class="code" href="group__avr__interrupts.html#g3b991e8168db8fc866e31f9a6d10533b">reti</a>();
}
</pre></div><p>
<h3>Choosing the vector: Interrupt vector names</h3>
<p>
The interrupt is chosen by supplying one of the symbols in following table.<p>
There are currently two different styles present for naming the vectors. One form uses names starting with <code>SIG_</code>, followed by a relatively verbose but arbitrarily chosen name describing the interrupt vector. This has been the only available style in avr-libc up to version 1.2.x.<p>
Starting with avr-libc version 1.4.0, a second style of interrupt vector names has been added, where a short phrase for the vector description is followed by <code>_vect</code>. The short phrase matches the vector name as described in the datasheet of the respective device (and in Atmel's XML files), with spaces replaced by an underscore and other non-alphanumeric characters dropped. Using the suffix <code>_vect</code> is intented to improve portability to other C compilers available for the AVR that use a similar naming convention.<p>
The historical naming style might become deprecated in a future release, so it is not recommended for new projects.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The <a class="el" href="group__avr__interrupts.html#gd28590624d422cdf30d626e0a506255f">ISR()</a> macro cannot really spell-check the argument passed to them. Thus, by misspelling one of the names below in a call to <a class="el" href="group__avr__interrupts.html#gd28590624d422cdf30d626e0a506255f">ISR()</a>, a function will be created that, while possibly being usable as an interrupt function, is not actually wired into the interrupt vector table. The compiler will generate a warning if it detects a suspiciously looking name of a <a class="el" href="group__avr__interrupts.html#gd28590624d422cdf30d626e0a506255f">ISR()</a> function (i.e. one that after macro replacement does not start with "__vector_").</dd></dl>
<a class="anchor" name="avr_signames"></a> <small> <table border="3" cellspacing="3" cellpadding="3">
<tr>
<td width="20%"><b>Vector name</b> </td><td width="20%"><b>Old vector name</b> </td><td width="20%"><b>Description</b> </td><td width="40%"><b>Applicable for device</b> <p>
</td></tr>
<tr>
<td>ADC_vect </td><td>SIG_ADC </td><td>ADC Conversion Complete </td><td>AT90S2333, AT90S4433, AT90S4434, AT90S8535, AT90PWM216, AT90PWM2B, AT90PWM316, AT90PWM3B, AT90PWM3, AT90PWM2, AT90PWM1, AT90CAN128, AT90CAN32, AT90CAN64, ATmega103, ATmega128, ATmega1284P, ATmega16, ATmega163, ATmega165, ATmega165P, ATmega168P, ATmega169, ATmega169P, ATmega32, ATmega323, ATmega325, ATmega3250, ATmega3250P, ATmega328P, ATmega329, ATmega3290, ATmega3290P, ATmega48P, ATmega64, ATmega645, ATmega6450, ATmega649, ATmega6490, ATmega8, ATmega8535, ATmega88P, ATmega168, ATmega48, ATmega88, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, ATmega324P, ATmega164P, ATmega644P, ATmega644, ATtiny13, ATtiny15, ATtiny26, ATtiny43U, ATtiny48, ATtiny24, ATtiny44, ATtiny84, ATtiny45, ATtiny25, ATtiny85, ATtiny261, ATtiny461, ATtiny861, AT90USB1287, AT90USB1286, AT90USB647, AT90USB646  </td></tr>
<tr>
<td>ANALOG_COMP_0_vect </td><td>SIG_COMPARATOR0 </td><td>Analog Comparator 0 </td><td>AT90PWM3, AT90PWM2, AT90PWM1  </td></tr>
<tr>
<td>ANALOG_COMP_1_vect </td><td>SIG_COMPARATOR1 </td><td>Analog Comparator 1 </td><td>AT90PWM3, AT90PWM2, AT90PWM1  </td></tr>
<tr>
<td>ANALOG_COMP_2_vect </td><td>SIG_COMPARATOR2 </td><td>Analog Comparator 2 </td><td>AT90PWM3, AT90PWM2, AT90PWM1  </td></tr>
<tr>
<td>ANALOG_COMP_vect </td><td>SIG_COMPARATOR </td><td>Analog Comparator </td><td>AT90CAN128, AT90CAN32, AT90CAN64, ATmega103, ATmega128, ATmega1284P, ATmega165, ATmega165P, ATmega168P, ATmega169, ATmega169P, ATmega325, ATmega3250, ATmega3250P, ATmega328P, ATmega329, ATmega3290, ATmega3290P, ATmega48P, ATmega64, ATmega645, ATmega6450, ATmega649, ATmega6490, ATmega88P, ATmega168, ATmega48, ATmega88, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, ATmega324P, ATmega164P, ATmega644P, ATmega644, AT90USB162, AT90USB82, AT90USB1287, AT90USB1286, AT90USB647, AT90USB646  </td></tr>
<tr>
<td>ANA_COMP_vect </td><td>SIG_COMPARATOR </td><td>Analog Comparator </td><td>AT90S1200, AT90S2313, AT90S2333, AT90S4414, AT90S4433, AT90S4434, AT90S8515, AT90S8535, ATmega16, ATmega161, ATmega162, ATmega163, ATmega32, ATmega323, ATmega8, ATmega8515, ATmega8535, ATtiny11, ATtiny12, ATtiny13, ATtiny15, ATtiny2313, ATtiny26, ATtiny28, ATtiny43U, ATtiny48, ATtiny24, ATtiny44, ATtiny84, ATtiny45, ATtiny25, ATtiny85, ATtiny261, ATtiny461, ATtiny861  </td></tr>
<tr>
<td>CANIT_vect </td><td>SIG_CAN_INTERRUPT1 </td><td>CAN Transfer Complete or Error </td><td>AT90CAN128, AT90CAN32, AT90CAN64  </td></tr>
<tr>
<td>EEPROM_READY_vect </td><td>SIG_EEPROM_READY, SIG_EE_READY </td><td></td><td>ATtiny2313  </td></tr>
<tr>
<td>EE_RDY_vect </td><td>SIG_EEPROM_READY </td><td>EEPROM Ready </td><td>AT90S2333, AT90S4433, AT90S4434, AT90S8535, ATmega16, ATmega161, ATmega162, ATmega163, ATmega32, ATmega323, ATmega8, ATmega8515, ATmega8535, ATtiny12, ATtiny13, ATtiny15, ATtiny26, ATtiny43U, ATtiny48, ATtiny24, ATtiny44, ATtiny84, ATtiny45, ATtiny25, ATtiny85, ATtiny261, ATtiny461, ATtiny861  </td></tr>
<tr>
<td>EE_READY_vect </td><td>SIG_EEPROM_READY </td><td>EEPROM Ready </td><td>AT90PWM3, AT90PWM2, AT90PWM1, AT90CAN128, AT90CAN32, AT90CAN64, ATmega103, ATmega128, ATmega1284P, ATmega165, ATmega165P, ATmega168P, ATmega169, ATmega169P, ATmega325, ATmega3250, ATmega3250P, ATmega328P, ATmega329, ATmega3290, ATmega3290P, ATmega32HVB, ATmega406, ATmega48P, ATmega64, ATmega645, ATmega6450, ATmega649, ATmega6490, ATmega88P, ATmega168, ATmega48, ATmega88, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, ATmega324P, ATmega164P, ATmega644P, ATmega644, ATmega16HVA, AT90USB162, AT90USB82, AT90USB1287, AT90USB1286, AT90USB647, AT90USB646  </td></tr>
<tr>
<td>EXT_INT0_vect </td><td>SIG_INTERRUPT0 </td><td>External Interrupt Request 0 </td><td>ATtiny24, ATtiny44, ATtiny84  </td></tr>
<tr>
<td>INT0_vect </td><td>SIG_INTERRUPT0 </td><td>External Interrupt 0 </td><td>AT90S1200, AT90S2313, AT90S2323, AT90S2333, AT90S2343, AT90S4414, AT90S4433, AT90S4434, AT90S8515, AT90S8535, AT90PWM216, AT90PWM2B, AT90PWM316, AT90PWM3B, AT90PWM3, AT90PWM2, AT90PWM1, AT90CAN128, AT90CAN32, AT90CAN64, ATmega103, ATmega128, ATmega1284P, ATmega16, ATmega161, ATmega162, ATmega163, ATmega165, ATmega165P, ATmega168P, ATmega169, ATmega169P, ATmega32, ATmega323, ATmega325, ATmega3250, ATmega3250P, ATmega328P, ATmega329, ATmega3290, ATmega3290P, ATmega32HVB, ATmega406, ATmega48P, ATmega64, ATmega645, ATmega6450, ATmega649, ATmega6490, ATmega8, ATmega8515, ATmega8535, ATmega88P, ATmega168, ATmega48, ATmega88, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, ATmega324P, ATmega164P, ATmega644P, ATmega644, ATmega16HVA, ATtiny11, ATtiny12, ATtiny13, ATtiny15, ATtiny22, ATtiny2313, ATtiny26, ATtiny28, ATtiny43U, ATtiny48, ATtiny45, ATtiny25, ATtiny85, ATtiny261, ATtiny461, ATtiny861, AT90USB162, AT90USB82, AT90USB1287, AT90USB1286, AT90USB647, AT90USB646  </td></tr>
<tr>
<td>INT1_vect </td><td>SIG_INTERRUPT1 </td><td>External Interrupt Request 1 </td><td>AT90S2313, AT90S2333, AT90S4414, AT90S4433, AT90S4434, AT90S8515, AT90S8535, AT90PWM216, AT90PWM2B, AT90PWM316, AT90PWM3B, AT90PWM3, AT90PWM2, AT90PWM1, AT90CAN128, AT90CAN32, AT90CAN64, ATmega103, ATmega128, ATmega1284P, ATmega16, ATmega161, ATmega162, ATmega163, ATmega168P, ATmega32, ATmega323, ATmega328P, ATmega32HVB, ATmega406, ATmega48P, ATmega64, ATmega8, ATmega8515, ATmega8535, ATmega88P, ATmega168, ATmega48, ATmega88, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, ATmega324P, ATmega164P, ATmega644P, ATmega644, ATmega16HVA, ATtiny2313, ATtiny28, ATtiny48, ATtiny261, ATtiny461, ATtiny861, AT90USB162, AT90USB82, AT90USB1287, AT90USB1286, AT90USB647, AT90USB646  </td></tr>
<tr>
<td>INT2_vect </td><td>SIG_INTERRUPT2 </td><td>External Interrupt Request 2 </td><td>AT90PWM3, AT90PWM2, AT90PWM1, AT90CAN128, AT90CAN32, AT90CAN64, ATmega103, ATmega128, ATmega1284P, ATmega16, ATmega161, ATmega162, ATmega32, ATmega323, ATmega32HVB, ATmega406, ATmega64, ATmega8515, ATmega8535, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, ATmega324P, ATmega164P, ATmega644P, ATmega644, ATmega16HVA, AT90USB162, AT90USB82, AT90USB1287, AT90USB1286, AT90USB647, AT90USB646  </td></tr>
<tr>
<td>INT3_vect </td><td>SIG_INTERRUPT3 </td><td>External Interrupt Request 3 </td><td>AT90PWM3, AT90PWM2, AT90PWM1, AT90CAN128, AT90CAN32, AT90CAN64, ATmega103, ATmega128, ATmega32HVB, ATmega406, ATmega64, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, AT90USB162, AT90USB82, AT90USB1287, AT90USB1286, AT90USB647, AT90USB646  </td></tr>
<tr>
<td>INT4_vect </td><td>SIG_INTERRUPT4 </td><td>External Interrupt Request 4 </td><td>AT90CAN128, AT90CAN32, AT90CAN64, ATmega103, ATmega128, ATmega64, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, AT90USB162, AT90USB82, AT90USB1287, AT90USB1286, AT90USB647, AT90USB646  </td></tr>
<tr>
<td>INT5_vect </td><td>SIG_INTERRUPT5 </td><td>External Interrupt Request 5 </td><td>AT90CAN128, AT90CAN32, AT90CAN64, ATmega103, ATmega128, ATmega64, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, AT90USB162, AT90USB82, AT90USB1287, AT90USB1286, AT90USB647, AT90USB646  </td></tr>
<tr>
<td>INT6_vect </td><td>SIG_INTERRUPT6 </td><td>External Interrupt Request 6 </td><td>AT90CAN128, AT90CAN32, AT90CAN64, ATmega103, ATmega128, ATmega64, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, AT90USB162, AT90USB82, AT90USB1287, AT90USB1286, AT90USB647, AT90USB646  </td></tr>
<tr>
<td>INT7_vect </td><td>SIG_INTERRUPT7 </td><td>External Interrupt Request 7 </td><td>AT90CAN128, AT90CAN32, AT90CAN64, ATmega103, ATmega128, ATmega64, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, AT90USB162, AT90USB82, AT90USB1287, AT90USB1286, AT90USB647, AT90USB646  </td></tr>
<tr>
<td>IO_PINS_vect </td><td>SIG_PIN, SIG_PIN_CHANGE </td><td>External Interrupt Request 0 </td><td>ATtiny11, ATtiny12, ATtiny15, ATtiny26  </td></tr>
<tr>
<td>LCD_vect </td><td>SIG_LCD </td><td>LCD Start of Frame </td><td>ATmega169, ATmega169P, ATmega329, ATmega3290, ATmega3290P, ATmega649, ATmega6490  </td></tr>
<tr>
<td>LOWLEVEL_IO_PINS_vect </td><td>SIG_PIN </td><td>Low-level Input on Port B </td><td>ATtiny28  </td></tr>
<tr>
<td>OVRIT_vect </td><td>SIG_CAN_OVERFLOW1 </td><td>CAN Timer Overrun </td><td>AT90CAN128, AT90CAN32, AT90CAN64  </td></tr>
<tr>
<td>PCINT0_vect </td><td>SIG_PIN_CHANGE0 </td><td>Pin Change Interrupt Request 0 </td><td>ATmega162, ATmega165, ATmega165P, ATmega168P, ATmega169, ATmega169P, ATmega325, ATmega3250, ATmega3250P, ATmega328P, ATmega329, ATmega3290, ATmega3290P, ATmega32HVB, ATmega406, ATmega48P, ATmega645, ATmega6450, ATmega649, ATmega6490, ATmega88P, ATmega168, ATmega48, ATmega88, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, ATmega324P, ATmega164P, ATmega644P, ATmega644, ATtiny13, ATtiny43U, ATtiny48, ATtiny24, ATtiny44, ATtiny84, ATtiny45, ATtiny25, ATtiny85, AT90USB162, AT90USB82, AT90USB1287, AT90USB1286, AT90USB647, AT90USB646  </td></tr>
<tr>
<td>PCINT1_vect </td><td>SIG_PIN_CHANGE1 </td><td>Pin Change Interrupt Request 1 </td><td>ATmega162, ATmega165, ATmega165P, ATmega168P, ATmega169, ATmega169P, ATmega325, ATmega3250, ATmega3250P, ATmega328P, ATmega329, ATmega3290, ATmega3290P, ATmega32HVB, ATmega406, ATmega48P, ATmega645, ATmega6450, ATmega649, ATmega6490, ATmega88P, ATmega168, ATmega48, ATmega88, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, ATmega324P, ATmega164P, ATmega644P, ATmega644, ATtiny43U, ATtiny48, ATtiny24, ATtiny44, ATtiny84, AT90USB162, AT90USB82  </td></tr>
<tr>
<td>PCINT2_vect </td><td>SIG_PIN_CHANGE2 </td><td>Pin Change Interrupt Request 2 </td><td>ATmega3250, ATmega3250P, ATmega328P, ATmega3290, ATmega3290P, ATmega48P, ATmega6450, ATmega6490, ATmega88P, ATmega168, ATmega48, ATmega88, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, ATmega324P, ATmega164P, ATmega644P, ATmega644, ATtiny48  </td></tr>
<tr>
<td>PCINT3_vect </td><td>SIG_PIN_CHANGE3 </td><td>Pin Change Interrupt Request 3 </td><td>ATmega3250, ATmega3250P, ATmega3290, ATmega3290P, ATmega6450, ATmega6490, ATmega324P, ATmega164P, ATmega644P, ATmega644, ATtiny48  </td></tr>
<tr>
<td>PCINT_vect </td><td>SIG_PIN_CHANGE, SIG_PCINT </td><td></td><td>ATtiny2313, ATtiny261, ATtiny461, ATtiny861  </td></tr>
<tr>
<td>PSC0_CAPT_vect </td><td>SIG_PSC0_CAPTURE </td><td>PSC0 Capture Event </td><td>AT90PWM3, AT90PWM2, AT90PWM1  </td></tr>
<tr>
<td>PSC0_EC_vect </td><td>SIG_PSC0_END_CYCLE </td><td>PSC0 End Cycle </td><td>AT90PWM3, AT90PWM2, AT90PWM1  </td></tr>
<tr>
<td>PSC1_CAPT_vect </td><td>SIG_PSC1_CAPTURE </td><td>PSC1 Capture Event </td><td>AT90PWM3, AT90PWM2, AT90PWM1  </td></tr>
<tr>
<td>PSC1_EC_vect </td><td>SIG_PSC1_END_CYCLE </td><td>PSC1 End Cycle </td><td>AT90PWM3, AT90PWM2, AT90PWM1  </td></tr>
<tr>
<td>PSC2_CAPT_vect </td><td>SIG_PSC2_CAPTURE </td><td>PSC2 Capture Event </td><td>AT90PWM3, AT90PWM2, AT90PWM1  </td></tr>
<tr>
<td>PSC2_EC_vect </td><td>SIG_PSC2_END_CYCLE </td><td>PSC2 End Cycle </td><td>AT90PWM3, AT90PWM2, AT90PWM1  </td></tr>
<tr>
<td>SPI_STC_vect </td><td>SIG_SPI </td><td>Serial Transfer Complete </td><td>AT90S2333, AT90S4414, AT90S4433, AT90S4434, AT90S8515, AT90S8535, AT90PWM216, AT90PWM2B, AT90PWM316, AT90PWM3B, AT90PWM3, AT90PWM2, AT90PWM1, AT90CAN128, AT90CAN32, AT90CAN64, ATmega103, ATmega128, ATmega1284P, ATmega16, ATmega161, ATmega162, ATmega163, ATmega165, ATmega165P, ATmega168P, ATmega169, ATmega169P, ATmega32, ATmega323, ATmega325, ATmega3250, ATmega3250P, ATmega328P, ATmega329, ATmega3290, ATmega3290P, ATmega32HVB, ATmega48P, ATmega64, ATmega645, ATmega6450, ATmega649, ATmega6490, ATmega8, ATmega8515, ATmega8535, ATmega88P, ATmega168, ATmega48, ATmega88, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, ATmega324P, ATmega164P, ATmega644P, ATmega644, ATmega16HVA, ATtiny48, AT90USB162, AT90USB82, AT90USB1287, AT90USB1286, AT90USB647, AT90USB646  </td></tr>
<tr>
<td>SPM_RDY_vect </td><td>SIG_SPM_READY </td><td>Store Program Memory Ready </td><td>ATmega16, ATmega162, ATmega32, ATmega323, ATmega8, ATmega8515, ATmega8535  </td></tr>
<tr>
<td>SPM_READY_vect </td><td>SIG_SPM_READY </td><td>Store Program Memory Read </td><td>AT90PWM3, AT90PWM2, AT90PWM1, AT90CAN128, AT90CAN32, AT90CAN64, ATmega128, ATmega1284P, ATmega165, ATmega165P, ATmega168P, ATmega169, ATmega169P, ATmega325, ATmega3250, ATmega3250P, ATmega328P, ATmega329, ATmega3290, ATmega3290P, ATmega406, ATmega48P, ATmega64, ATmega645, ATmega6450, ATmega649, ATmega6490, ATmega88P, ATmega168, ATmega48, ATmega88, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, ATmega324P, ATmega164P, ATmega644P, ATmega644, AT90USB162, AT90USB82, AT90USB1287, AT90USB1286, AT90USB647, AT90USB646  </td></tr>
<tr>
<td>TIM0_COMPA_vect </td><td>SIG_OUTPUT_COMPARE0A </td><td>Timer/Counter Compare Match A </td><td>ATtiny13, ATtiny43U, ATtiny24, ATtiny44, ATtiny84, ATtiny45, ATtiny25, ATtiny85  </td></tr>
<tr>
<td>TIM0_COMPB_vect </td><td>SIG_OUTPUT_COMPARE0B </td><td>Timer/Counter Compare Match B </td><td>ATtiny13, ATtiny43U, ATtiny24, ATtiny44, ATtiny84, ATtiny45, ATtiny25, ATtiny85  </td></tr>
<tr>
<td>TIM0_OVF_vect </td><td>SIG_OVERFLOW0 </td><td>Timer/Counter0 Overflow </td><td>ATtiny13, ATtiny43U, ATtiny24, ATtiny44, ATtiny84, ATtiny45, ATtiny25, ATtiny85  </td></tr>
<tr>
<td>TIM1_CAPT_vect </td><td>SIG_INPUT_CAPTURE1 </td><td>Timer/Counter1 Capture Event </td><td>ATtiny24, ATtiny44, ATtiny84  </td></tr>
<tr>
<td>TIM1_COMPA_vect </td><td>SIG_OUTPUT_COMPARE1A </td><td>Timer/Counter1 Compare Match A </td><td>ATtiny24, ATtiny44, ATtiny84, ATtiny45, ATtiny25, ATtiny85  </td></tr>
<tr>
<td>TIM1_COMPB_vect </td><td>SIG_OUTPUT_COMPARE1B </td><td>Timer/Counter1 Compare Match B </td><td>ATtiny24, ATtiny44, ATtiny84, ATtiny45, ATtiny25, ATtiny85  </td></tr>
<tr>
<td>TIM1_OVF_vect </td><td>SIG_OVERFLOW1 </td><td>Timer/Counter1 Overflow </td><td>ATtiny24, ATtiny44, ATtiny84, ATtiny45, ATtiny25, ATtiny85  </td></tr>
<tr>
<td>TIMER0_CAPT_vect </td><td>SIG_INPUT_CAPTURE0 </td><td>ADC Conversion Complete </td><td>ATtiny261, ATtiny461, ATtiny861  </td></tr>
<tr>
<td>TIMER0_COMPA_vect </td><td>SIG_OUTPUT_COMPARE0A </td><td>TimerCounter0 Compare Match A </td><td>ATmega168, ATmega48, ATmega88, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, ATmega324P, ATmega164P, ATmega644P, ATmega644, ATmega16HVA, ATtiny2313, ATtiny48, ATtiny261, ATtiny461, ATtiny861, AT90USB162, AT90USB82, AT90USB1287, AT90USB1286, AT90USB647, AT90USB646  </td></tr>
<tr>
<td>TIMER0_COMPB_vect </td><td>SIG_OUTPUT_COMPARE0B, SIG_OUTPUT_COMPARE0_B </td><td>Timer Counter 0 Compare Match B </td><td>AT90PWM3, AT90PWM2, AT90PWM1, ATmega1284P, ATmega168P, ATmega328P, ATmega32HVB, ATmega48P, ATmega88P, ATmega168, ATmega48, ATmega88, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, ATmega324P, ATmega164P, ATmega644P, ATmega644, ATmega16HVA, ATtiny2313, ATtiny48, ATtiny261, ATtiny461, ATtiny861, AT90USB162, AT90USB82, AT90USB1287, AT90USB1286, AT90USB647, AT90USB646  </td></tr>
<tr>
<td>TIMER0_COMP_A_vect </td><td>SIG_OUTPUT_COMPARE0A, SIG_OUTPUT_COMPARE0_A </td><td>Timer/Counter0 Compare Match A </td><td>AT90PWM3, AT90PWM2, AT90PWM1  </td></tr>
<tr>
<td>TIMER0_COMP_vect </td><td>SIG_OUTPUT_COMPARE0 </td><td>Timer/Counter0 Compare Match </td><td>AT90CAN128, AT90CAN32, AT90CAN64, ATmega103, ATmega128, ATmega16, ATmega161, ATmega162, ATmega165, ATmega165P, ATmega169, ATmega169P, ATmega32, ATmega323, ATmega325, ATmega3250, ATmega3250P, ATmega329, ATmega3290, ATmega3290P, ATmega64, ATmega645, ATmega6450, ATmega649, ATmega6490, ATmega8515, ATmega8535  </td></tr>
<tr>
<td>TIMER0_OVF0_vect </td><td>SIG_OVERFLOW0 </td><td>Timer/Counter0 Overflow </td><td>AT90S2313, AT90S2323, AT90S2343, ATtiny22, ATtiny26  </td></tr>
<tr>
<td>TIMER0_OVF_vect </td><td>SIG_OVERFLOW0 </td><td>Timer/Counter0 Overflow </td><td>AT90S1200, AT90S2333, AT90S4414, AT90S4433, AT90S4434, AT90S8515, AT90S8535, AT90PWM216, AT90PWM2B, AT90PWM316, AT90PWM3B, AT90PWM3, AT90PWM2, AT90PWM1, AT90CAN128, AT90CAN32, AT90CAN64, ATmega103, ATmega128, ATmega1284P, ATmega16, ATmega161, ATmega162, ATmega163, ATmega165, ATmega165P, ATmega168P, ATmega169, ATmega169P, ATmega32, ATmega323, ATmega325, ATmega3250, ATmega3250P, ATmega328P, ATmega329, ATmega3290, ATmega3290P, ATmega32HVB, ATmega48P, ATmega64, ATmega645, ATmega6450, ATmega649, ATmega6490, ATmega8, ATmega8515, ATmega8535, ATmega88P, ATmega168, ATmega48, ATmega88, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, ATmega324P, ATmega164P, ATmega644P, ATmega644, ATmega16HVA, ATtiny11, ATtiny12, ATtiny15, ATtiny2313, ATtiny28, ATtiny48, ATtiny261, ATtiny461, ATtiny861, AT90USB162, AT90USB82, AT90USB1287, AT90USB1286, AT90USB647, AT90USB646  </td></tr>
<tr>
<td>TIMER1_CAPT1_vect </td><td>SIG_INPUT_CAPTURE1 </td><td>Timer/Counter1 Capture Event </td><td>AT90S2313  </td></tr>
<tr>
<td>TIMER1_CAPT_vect </td><td>SIG_INPUT_CAPTURE1 </td><td>Timer/Counter Capture Event </td><td>AT90S2333, AT90S4414, AT90S4433, AT90S4434, AT90S8515, AT90S8535, AT90PWM216, AT90PWM2B, AT90PWM316, AT90PWM3B, AT90PWM3, AT90PWM2, AT90PWM1, AT90CAN128, AT90CAN32, AT90CAN64, ATmega103, ATmega128, ATmega1284P, ATmega16, ATmega161, ATmega162, ATmega163, ATmega165, ATmega165P, ATmega168P, ATmega169, ATmega169P, ATmega32, ATmega323, ATmega325, ATmega3250, ATmega3250P, ATmega328P, ATmega329, ATmega3290, ATmega3290P, ATmega48P, ATmega64, ATmega645, ATmega6450, ATmega649, ATmega6490, ATmega8, ATmega8515, ATmega8535, ATmega88P, ATmega168, ATmega48, ATmega88, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, ATmega324P, ATmega164P, ATmega644P, ATmega644, ATtiny2313, ATtiny48, AT90USB162, AT90USB82, AT90USB1287, AT90USB1286, AT90USB647, AT90USB646  </td></tr>
<tr>
<td>TIMER1_CMPA_vect </td><td>SIG_OUTPUT_COMPARE1A </td><td>Timer/Counter1 Compare Match 1A </td><td>ATtiny26  </td></tr>
<tr>
<td>TIMER1_CMPB_vect </td><td>SIG_OUTPUT_COMPARE1B </td><td>Timer/Counter1 Compare Match 1B </td><td>ATtiny26  </td></tr>
<tr>
<td>TIMER1_COMP1_vect </td><td>SIG_OUTPUT_COMPARE1A </td><td>Timer/Counter1 Compare Match </td><td>AT90S2313  </td></tr>
<tr>
<td>TIMER1_COMPA_vect </td><td>SIG_OUTPUT_COMPARE1A </td><td>Timer/Counter1 Compare Match A </td><td>AT90S4414, AT90S4434, AT90S8515, AT90S8535, AT90PWM216, AT90PWM2B, AT90PWM316, AT90PWM3B, AT90PWM3, AT90PWM2, AT90PWM1, AT90CAN128, AT90CAN32, AT90CAN64, ATmega103, ATmega128, ATmega1284P, ATmega16, ATmega161, ATmega162, ATmega163, ATmega165, ATmega165P, ATmega168P, ATmega169, ATmega169P, ATmega32, ATmega323, ATmega325, ATmega3250, ATmega3250P, ATmega328P, ATmega329, ATmega3290, ATmega3290P, ATmega32HVB, ATmega48P, ATmega64, ATmega645, ATmega6450, ATmega649, ATmega6490, ATmega8, ATmega8515, ATmega8535, ATmega88P, ATmega168, ATmega48, ATmega88, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, ATmega324P, ATmega164P, ATmega644P, ATmega644, ATmega16HVA, ATtiny2313, ATtiny48, ATtiny261, ATtiny461, ATtiny861, AT90USB162, AT90USB82, AT90USB1287, AT90USB1286, AT90USB647, AT90USB646  </td></tr>
<tr>
<td>TIMER1_COMPB_vect </td><td>SIG_OUTPUT_COMPARE1B </td><td>Timer/Counter1 Compare MatchB </td><td>AT90S4414, AT90S4434, AT90S8515, AT90S8535, AT90PWM216, AT90PWM2B, AT90PWM316, AT90PWM3B, AT90PWM3, AT90PWM2, AT90PWM1, AT90CAN128, AT90CAN32, AT90CAN64, ATmega103, ATmega128, ATmega1284P, ATmega16, ATmega161, ATmega162, ATmega163, ATmega165, ATmega165P, ATmega168P, ATmega169, ATmega169P, ATmega32, ATmega323, ATmega325, ATmega3250, ATmega3250P, ATmega328P, ATmega329, ATmega3290, ATmega3290P, ATmega32HVB, ATmega48P, ATmega64, ATmega645, ATmega6450, ATmega649, ATmega6490, ATmega8, ATmega8515, ATmega8535, ATmega88P, ATmega168, ATmega48, ATmega88, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, ATmega324P, ATmega164P, ATmega644P, ATmega644, ATmega16HVA, ATtiny2313, ATtiny48, ATtiny261, ATtiny461, ATtiny861, AT90USB162, AT90USB82, AT90USB1287, AT90USB1286, AT90USB647, AT90USB646  </td></tr>
<tr>
<td>TIMER1_COMPC_vect </td><td>SIG_OUTPUT_COMPARE1C </td><td>Timer/Counter1 Compare Match C </td><td>AT90CAN128, AT90CAN32, AT90CAN64, ATmega128, ATmega64, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, AT90USB162, AT90USB82, AT90USB1287, AT90USB1286, AT90USB647, AT90USB646  </td></tr>
<tr>
<td>TIMER1_COMPD_vect </td><td>SIG_OUTPUT_COMPARE0D </td><td>Timer/Counter1 Compare Match D </td><td>ATtiny261, ATtiny461, ATtiny861  </td></tr>
<tr>
<td>TIMER1_COMP_vect </td><td>SIG_OUTPUT_COMPARE1A </td><td>Timer/Counter1 Compare Match </td><td>AT90S2333, AT90S4433, ATtiny15  </td></tr>
<tr>
<td>TIMER1_OVF1_vect </td><td>SIG_OVERFLOW1 </td><td>Timer/Counter1 Overflow </td><td>AT90S2313, ATtiny26  </td></tr>
<tr>
<td>TIMER1_OVF_vect </td><td>SIG_OVERFLOW1 </td><td>Timer/Counter1 Overflow </td><td>AT90S2333, AT90S4414, AT90S4433, AT90S4434, AT90S8515, AT90S8535, AT90PWM216, AT90PWM2B, AT90PWM316, AT90PWM3B, AT90PWM3, AT90PWM2, AT90PWM1, AT90CAN128, AT90CAN32, AT90CAN64, ATmega103, ATmega128, ATmega1284P, ATmega16, ATmega161, ATmega162, ATmega163, ATmega165, ATmega165P, ATmega168P, ATmega169, ATmega169P, ATmega32, ATmega323, ATmega325, ATmega3250, ATmega3250P, ATmega328P, ATmega329, ATmega3290, ATmega3290P, ATmega32HVB, ATmega48P, ATmega64, ATmega645, ATmega6450, ATmega649, ATmega6490, ATmega8, ATmega8515, ATmega8535, ATmega88P, ATmega168, ATmega48, ATmega88, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, ATmega324P, ATmega164P, ATmega644P, ATmega644, ATmega16HVA, ATtiny15, ATtiny2313, ATtiny48, ATtiny261, ATtiny461, ATtiny861, AT90USB162, AT90USB82, AT90USB1287, AT90USB1286, AT90USB647, AT90USB646  </td></tr>
<tr>
<td>TIMER2_COMPA_vect </td><td>SIG_OUTPUT_COMPARE2A </td><td>Timer/Counter2 Compare Match A </td><td>ATmega168, ATmega48, ATmega88, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, ATmega324P, ATmega164P, ATmega644P, ATmega644, AT90USB1287, AT90USB1286, AT90USB647, AT90USB646  </td></tr>
<tr>
<td>TIMER2_COMPB_vect </td><td>SIG_OUTPUT_COMPARE2B </td><td>Timer/Counter2 Compare Match A </td><td>ATmega168, ATmega48, ATmega88, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, ATmega324P, ATmega164P, ATmega644P, ATmega644, AT90USB1287, AT90USB1286, AT90USB647, AT90USB646  </td></tr>
<tr>
<td>TIMER2_COMP_vect </td><td>SIG_OUTPUT_COMPARE2 </td><td>Timer/Counter2 Compare Match </td><td>AT90S4434, AT90S8535, AT90CAN128, AT90CAN32, AT90CAN64, ATmega103, ATmega128, ATmega16, ATmega161, ATmega162, ATmega163, ATmega165, ATmega165P, ATmega169, ATmega169P, ATmega32, ATmega323, ATmega325, ATmega3250, ATmega3250P, ATmega329, ATmega3290, ATmega3290P, ATmega64, ATmega645, ATmega6450, ATmega649, ATmega6490, ATmega8, ATmega8535  </td></tr>
<tr>
<td>TIMER2_OVF_vect </td><td>SIG_OVERFLOW2 </td><td>Timer/Counter2 Overflow </td><td>AT90S4434, AT90S8535, AT90CAN128, AT90CAN32, AT90CAN64, ATmega103, ATmega128, ATmega1284P, ATmega16, ATmega161, ATmega162, ATmega163, ATmega165, ATmega165P, ATmega168P, ATmega169, ATmega169P, ATmega32, ATmega323, ATmega325, ATmega3250, ATmega3250P, ATmega328P, ATmega329, ATmega3290, ATmega3290P, ATmega48P, ATmega64, ATmega645, ATmega6450, ATmega649, ATmega6490, ATmega8, ATmega8535, ATmega88P, ATmega168, ATmega48, ATmega88, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, ATmega324P, ATmega164P, ATmega644P, ATmega644, AT90USB1287, AT90USB1286, AT90USB647, AT90USB646  </td></tr>
<tr>
<td>TIMER3_CAPT_vect </td><td>SIG_INPUT_CAPTURE3 </td><td>Timer/Counter3 Capture Event </td><td>AT90CAN128, AT90CAN32, AT90CAN64, ATmega128, ATmega1284P, ATmega162, ATmega64, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, AT90USB1287, AT90USB1286, AT90USB647, AT90USB646  </td></tr>
<tr>
<td>TIMER3_COMPA_vect </td><td>SIG_OUTPUT_COMPARE3A </td><td>Timer/Counter3 Compare Match A </td><td>AT90CAN128, AT90CAN32, AT90CAN64, ATmega128, ATmega1284P, ATmega162, ATmega64, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, AT90USB1287, AT90USB1286, AT90USB647, AT90USB646  </td></tr>
<tr>
<td>TIMER3_COMPB_vect </td><td>SIG_OUTPUT_COMPARE3B </td><td>Timer/Counter3 Compare Match B </td><td>AT90CAN128, AT90CAN32, AT90CAN64, ATmega128, ATmega1284P, ATmega162, ATmega64, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, AT90USB1287, AT90USB1286, AT90USB647, AT90USB646  </td></tr>
<tr>
<td>TIMER3_COMPC_vect </td><td>SIG_OUTPUT_COMPARE3C </td><td>Timer/Counter3 Compare Match C </td><td>AT90CAN128, AT90CAN32, AT90CAN64, ATmega128, ATmega64, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, AT90USB1287, AT90USB1286, AT90USB647, AT90USB646  </td></tr>
<tr>
<td>TIMER3_OVF_vect </td><td>SIG_OVERFLOW3 </td><td>Timer/Counter3 Overflow </td><td>AT90CAN128, AT90CAN32, AT90CAN64, ATmega128, ATmega1284P, ATmega162, ATmega64, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, AT90USB1287, AT90USB1286, AT90USB647, AT90USB646  </td></tr>
<tr>
<td>TIMER4_CAPT_vect </td><td>SIG_INPUT_CAPTURE4 </td><td>Timer/Counter4 Capture Event </td><td>ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561  </td></tr>
<tr>
<td>TIMER4_COMPA_vect </td><td>SIG_OUTPUT_COMPARE4A </td><td>Timer/Counter4 Compare Match A </td><td>ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561  </td></tr>
<tr>
<td>TIMER4_COMPB_vect </td><td>SIG_OUTPUT_COMPARE4B </td><td>Timer/Counter4 Compare Match B </td><td>ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561  </td></tr>
<tr>
<td>TIMER4_COMPC_vect </td><td>SIG_OUTPUT_COMPARE4C </td><td>Timer/Counter4 Compare Match C </td><td>ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561  </td></tr>
<tr>
<td>TIMER4_OVF_vect </td><td>SIG_OVERFLOW4 </td><td>Timer/Counter4 Overflow </td><td>ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561  </td></tr>
<tr>
<td>TIMER5_CAPT_vect </td><td>SIG_INPUT_CAPTURE5 </td><td>Timer/Counter5 Capture Event </td><td>ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561  </td></tr>
<tr>
<td>TIMER5_COMPA_vect </td><td>SIG_OUTPUT_COMPARE5A </td><td>Timer/Counter5 Compare Match A </td><td>ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561  </td></tr>
<tr>
<td>TIMER5_COMPB_vect </td><td>SIG_OUTPUT_COMPARE5B </td><td>Timer/Counter5 Compare Match B </td><td>ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561  </td></tr>
<tr>
<td>TIMER5_COMPC_vect </td><td>SIG_OUTPUT_COMPARE5C </td><td>Timer/Counter5 Compare Match C </td><td>ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561  </td></tr>
<tr>
<td>TIMER5_OVF_vect </td><td>SIG_OVERFLOW5 </td><td>Timer/Counter5 Overflow </td><td>ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561  </td></tr>
<tr>
<td>TWI_vect </td><td>SIG_2WIRE_SERIAL </td><td>2-wire Serial Interface </td><td>AT90CAN128, AT90CAN32, AT90CAN64, ATmega128, ATmega1284P, ATmega16, ATmega163, ATmega168P, ATmega32, ATmega323, ATmega328P, ATmega32HVB, ATmega406, ATmega48P, ATmega64, ATmega8, ATmega8535, ATmega88P, ATmega168, ATmega48, ATmega88, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, ATmega324P, ATmega164P, ATmega644P, ATmega644, ATtiny48, AT90USB1287, AT90USB1286, AT90USB647, AT90USB646  </td></tr>
<tr>
<td>TXDONE_vect </td><td>SIG_TXDONE </td><td>Transmission Done, Bit Timer Flag 2 Interrupt </td><td>AT86RF401  </td></tr>
<tr>
<td>TXEMPTY_vect </td><td>SIG_TXBE </td><td>Transmit Buffer Empty, Bit Itmer Flag 0 Interrupt </td><td>AT86RF401  </td></tr>
<tr>
<td>UART0_RX_vect </td><td>SIG_UART0_RECV </td><td>UART0, Rx Complete </td><td>ATmega161  </td></tr>
<tr>
<td>UART0_TX_vect </td><td>SIG_UART0_TRANS </td><td>UART0, Tx Complete </td><td>ATmega161  </td></tr>
<tr>
<td>UART0_UDRE_vect </td><td>SIG_UART0_DATA </td><td>UART0 Data Register Empty </td><td>ATmega161  </td></tr>
<tr>
<td>UART1_RX_vect </td><td>SIG_UART1_RECV </td><td>UART1, Rx Complete </td><td>ATmega161  </td></tr>
<tr>
<td>UART1_TX_vect </td><td>SIG_UART1_TRANS </td><td>UART1, Tx Complete </td><td>ATmega161  </td></tr>
<tr>
<td>UART1_UDRE_vect </td><td>SIG_UART1_DATA </td><td>UART1 Data Register Empty </td><td>ATmega161  </td></tr>
<tr>
<td>UART_RX_vect </td><td>SIG_UART_RECV </td><td>UART, Rx Complete </td><td>AT90S2313, AT90S2333, AT90S4414, AT90S4433, AT90S4434, AT90S8515, AT90S8535, ATmega103, ATmega163, ATmega8515  </td></tr>
<tr>
<td>UART_TX_vect </td><td>SIG_UART_TRANS </td><td>UART, Tx Complete </td><td>AT90S2313, AT90S2333, AT90S4414, AT90S4433, AT90S4434, AT90S8515, AT90S8535, ATmega103, ATmega163, ATmega8515  </td></tr>
<tr>
<td>UART_UDRE_vect </td><td>SIG_UART_DATA </td><td>UART Data Register Empty </td><td>AT90S2313, AT90S2333, AT90S4414, AT90S4433, AT90S4434, AT90S8515, AT90S8535, ATmega103, ATmega163, ATmega8515  </td></tr>
<tr>
<td>USART0_RXC_vect </td><td>SIG_USART0_RECV </td><td>USART0, Rx Complete </td><td>ATmega162  </td></tr>
<tr>
<td>USART0_RX_vect </td><td>SIG_UART0_RECV </td><td>USART0, Rx Complete </td><td>AT90CAN128, AT90CAN32, AT90CAN64, ATmega128, ATmega1284P, ATmega165, ATmega165P, ATmega169, ATmega169P, ATmega325, ATmega329, ATmega64, ATmega645, ATmega649, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, ATmega324P, ATmega164P, ATmega644P, ATmega644  </td></tr>
<tr>
<td>USART0_TXC_vect </td><td>SIG_USART0_TRANS </td><td>USART0, Tx Complete </td><td>ATmega162  </td></tr>
<tr>
<td>USART0_TX_vect </td><td>SIG_UART0_TRANS </td><td>USART0, Tx Complete </td><td>AT90CAN128, AT90CAN32, AT90CAN64, ATmega128, ATmega1284P, ATmega165, ATmega165P, ATmega169, ATmega169P, ATmega325, ATmega3250, ATmega3250P, ATmega329, ATmega3290, ATmega3290P, ATmega64, ATmega645, ATmega6450, ATmega649, ATmega6490, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, ATmega324P, ATmega164P, ATmega644P, ATmega644  </td></tr>
<tr>
<td>USART0_UDRE_vect </td><td>SIG_UART0_DATA </td><td>USART0 Data Register Empty </td><td>AT90CAN128, AT90CAN32, AT90CAN64, ATmega128, ATmega1284P, ATmega162, ATmega165, ATmega165P, ATmega169, ATmega169P, ATmega325, ATmega329, ATmega64, ATmega645, ATmega649, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, ATmega324P, ATmega164P, ATmega644P, ATmega644  </td></tr>
<tr>
<td>USART1_RXC_vect </td><td>SIG_USART1_RECV </td><td>USART1, Rx Complete </td><td>ATmega162  </td></tr>
<tr>
<td>USART1_RX_vect </td><td>SIG_UART1_RECV </td><td>USART1, Rx Complete </td><td>AT90CAN128, AT90CAN32, AT90CAN64, ATmega128, ATmega1284P, ATmega64, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, ATmega324P, ATmega164P, ATmega644P, ATmega644, AT90USB162, AT90USB82, AT90USB1287, AT90USB1286, AT90USB647, AT90USB646  </td></tr>
<tr>
<td>USART1_TXC_vect </td><td>SIG_USART1_TRANS </td><td>USART1, Tx Complete </td><td>ATmega162  </td></tr>
<tr>
<td>USART1_TX_vect </td><td>SIG_UART1_TRANS </td><td>USART1, Tx Complete </td><td>AT90CAN128, AT90CAN32, AT90CAN64, ATmega128, ATmega1284P, ATmega64, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, ATmega324P, ATmega164P, ATmega644P, ATmega644, AT90USB162, AT90USB82, AT90USB1287, AT90USB1286, AT90USB647, AT90USB646  </td></tr>
<tr>
<td>USART1_UDRE_vect </td><td>SIG_UART1_DATA </td><td>USART1, Data Register Empty </td><td>AT90CAN128, AT90CAN32, AT90CAN64, ATmega128, ATmega1284P, ATmega162, ATmega64, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, ATmega324P, ATmega164P, ATmega644P, ATmega644, AT90USB162, AT90USB82, AT90USB1287, AT90USB1286, AT90USB647, AT90USB646  </td></tr>
<tr>
<td>USART2_RX_vect </td><td>SIG_USART2_RECV </td><td>USART2, Rx Complete </td><td>ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561  </td></tr>
<tr>
<td>USART2_TX_vect </td><td>SIG_USART2_TRANS </td><td>USART2, Tx Complete </td><td>ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561  </td></tr>
<tr>
<td>USART2_UDRE_vect </td><td>SIG_USART2_DATA </td><td>USART2 Data register Empty </td><td>ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561  </td></tr>
<tr>
<td>USART3_RX_vect </td><td>SIG_USART3_RECV </td><td>USART3, Rx Complete </td><td>ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561  </td></tr>
<tr>
<td>USART3_TX_vect </td><td>SIG_USART3_TRANS </td><td>USART3, Tx Complete </td><td>ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561  </td></tr>
<tr>
<td>USART3_UDRE_vect </td><td>SIG_USART3_DATA </td><td>USART3 Data register Empty </td><td>ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561  </td></tr>
<tr>
<td>USART_RXC_vect </td><td>SIG_USART_RECV, SIG_UART_RECV </td><td>USART, Rx Complete </td><td>ATmega16, ATmega32, ATmega323, ATmega8  </td></tr>
<tr>
<td>USART_RX_vect </td><td>SIG_USART_RECV, SIG_UART_RECV </td><td>USART, Rx Complete </td><td>AT90PWM3, AT90PWM2, AT90PWM1, ATmega168P, ATmega3250, ATmega3250P, ATmega328P, ATmega3290, ATmega3290P, ATmega48P, ATmega6450, ATmega6490, ATmega8535, ATmega88P, ATmega168, ATmega48, ATmega88, ATtiny2313  </td></tr>
<tr>
<td>USART_TXC_vect </td><td>SIG_USART_TRANS, SIG_UART_TRANS </td><td>USART, Tx Complete </td><td>ATmega16, ATmega32, ATmega323, ATmega8  </td></tr>
<tr>
<td>USART_TX_vect </td><td>SIG_USART_TRANS, SIG_UART_TRANS </td><td>USART, Tx Complete </td><td>AT90PWM3, AT90PWM2, AT90PWM1, ATmega168P, ATmega328P, ATmega48P, ATmega8535, ATmega88P, ATmega168, ATmega48, ATmega88, ATtiny2313  </td></tr>
<tr>
<td>USART_UDRE_vect </td><td>SIG_USART_DATA, SIG_UART_DATA </td><td>USART Data Register Empty </td><td>AT90PWM3, AT90PWM2, AT90PWM1, ATmega16, ATmega168P, ATmega32, ATmega323, ATmega3250, ATmega3250P, ATmega328P, ATmega3290, ATmega3290P, ATmega48P, ATmega6450, ATmega6490, ATmega8, ATmega8535, ATmega88P, ATmega168, ATmega48, ATmega88, ATtiny2313  </td></tr>
<tr>
<td>USI_OVERFLOW_vect </td><td>SIG_USI_OVERFLOW </td><td>USI Overflow </td><td>ATmega165, ATmega165P, ATmega169, ATmega169P, ATmega325, ATmega3250, ATmega3250P, ATmega329, ATmega3290, ATmega3290P, ATmega645, ATmega6450, ATmega649, ATmega6490, ATtiny2313  </td></tr>
<tr>
<td>USI_OVF_vect </td><td>SIG_USI_OVERFLOW </td><td>USI Overflow </td><td>ATtiny26, ATtiny43U, ATtiny24, ATtiny44, ATtiny84, ATtiny45, ATtiny25, ATtiny85, ATtiny261, ATtiny461, ATtiny861  </td></tr>
<tr>
<td>USI_START_vect </td><td>SIG_USI_START </td><td>USI Start Condition </td><td>ATmega165, ATmega165P, ATmega169, ATmega169P, ATmega325, ATmega3250, ATmega3250P, ATmega329, ATmega3290, ATmega3290P, ATmega645, ATmega6450, ATmega649, ATmega6490, ATtiny2313, ATtiny43U, ATtiny45, ATtiny25, ATtiny85, ATtiny261, ATtiny461, ATtiny861  </td></tr>
<tr>
<td>USI_STRT_vect </td><td>SIG_USI_START </td><td>USI Start </td><td>ATtiny26  </td></tr>
<tr>
<td>USI_STR_vect </td><td>SIG_USI_START </td><td>USI START </td><td>ATtiny24, ATtiny44, ATtiny84  </td></tr>
<tr>
<td>WATCHDOG_vect </td><td>SIG_WATCHDOG_TIMEOUT </td><td>Watchdog Time-out </td><td>ATtiny24, ATtiny44, ATtiny84  </td></tr>
<tr>
<td>WDT_OVERFLOW_vect </td><td>SIG_WATCHDOG_TIMEOUT, SIG_WDT_OVERFLOW </td><td>Watchdog Timer Overflow </td><td>ATtiny2313  </td></tr>
<tr>
<td>WDT_vect </td><td>SIG_WDT, SIG_WATCHDOG_TIMEOUT </td><td>Watchdog Timeout Interrupt </td><td>AT90PWM3, AT90PWM2, AT90PWM1, ATmega1284P, ATmega168P, ATmega328P, ATmega32HVB, ATmega406, ATmega48P, ATmega88P, ATmega168, ATmega48, ATmega88, ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561, ATmega324P, ATmega164P, ATmega644P, ATmega644, ATmega16HVA, ATtiny13, ATtiny43U, ATtiny48, ATtiny45, ATtiny25, ATtiny85, ATtiny261, ATtiny461, ATtiny861, AT90USB162, AT90USB82, AT90USB1287, AT90USB1286, AT90USB647, AT90USB646  </td></tr>
</table>
</small> <hr><h2>Define Documentation</h2>
<a class="anchor" name="g1f6459a85cda682b2163a20af03ac744"></a><!-- doxytag: member="interrupt.h::BADISR_vect" ref="g1f6459a85cda682b2163a20af03ac744" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BADISR_vect          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="interrupt_8h.html">avr/interrupt.h</a>&gt;</span> 
</pre></div><p>
This is a vector which is aliased to __vector_default, the vector executed when an ISR fires with no accompanying ISR handler. This may be used along with the <a class="el" href="group__avr__interrupts.html#gd28590624d422cdf30d626e0a506255f">ISR()</a> macro to create a catch-all for undefined but used ISRs for debugging purposes. 
</div>
</div><p>
<a class="anchor" name="g68c330e94fe121eba993e5a5973c3162"></a><!-- doxytag: member="interrupt.h::cli" ref="g68c330e94fe121eba993e5a5973c3162" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define cli          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="interrupt_8h.html">avr/interrupt.h</a>&gt;</span> 
</pre></div><p>
Disables all interrupts by clearing the global interrupt mask. This function actually compiles into a single line of assembly, so there is no function call overhead. 
</div>
</div><p>
<a class="anchor" name="g751c22101f7e8f2fbe792c64a81f8dba"></a><!-- doxytag: member="interrupt.h::EMPTY_INTERRUPT" ref="g751c22101f7e8f2fbe792c64a81f8dba" args="(vector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EMPTY_INTERRUPT          </td>
          <td>(</td>
          <td class="paramtype">vector&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="interrupt_8h.html">avr/interrupt.h</a>&gt;</span> 
</pre></div><p>
Defines an empty interrupt handler function. This will not generate any prolog or epilog code and will only return from the ISR. Do not define a function body as this will define it for you. Example: <div class="fragment"><pre class="fragment"> <a class="code" href="group__avr__interrupts.html#g751c22101f7e8f2fbe792c64a81f8dba">EMPTY_INTERRUPT</a>(ADC_vect);
</pre></div> 
</div>
</div><p>
<a class="anchor" name="gd28590624d422cdf30d626e0a506255f"></a><!-- doxytag: member="interrupt.h::ISR" ref="gd28590624d422cdf30d626e0a506255f" args="(vector, attributes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ISR          </td>
          <td>(</td>
          <td class="paramtype">vector,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">attributes&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="interrupt_8h.html">avr/interrupt.h</a>&gt;</span> 
</pre></div><p>
Introduces an interrupt handler function (interrupt service routine) that runs with global interrupts initially disabled by default with no attributes specified.<p>
The attributes are optional and alter the behaviour and resultant generated code of the interrupt routine. Multiple attributes may be used for a single function, with a space seperating each attribute.<p>
Valid attributes are ISR_BLOCK, ISR_NOBLOCK, ISR_NAKED and <a class="el" href="group__avr__interrupts.html#ga87c0c624b62f40a17539be6946c3e26">ISR_ALIASOF(vect)</a>.<p>
<code>vector</code> must be one of the interrupt vector names that are valid for the particular MCU type. 
</div>
</div><p>
<a class="anchor" name="gde46eb4e42cc9d56c19b1f91448f1b76"></a><!-- doxytag: member="interrupt.h::ISR_ALIAS" ref="gde46eb4e42cc9d56c19b1f91448f1b76" args="(vector, target_vector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ISR_ALIAS          </td>
          <td>(</td>
          <td class="paramtype">vector,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">target_vector&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="interrupt_8h.html">avr/interrupt.h</a>&gt;</span> 
</pre></div><p>
Aliases a given vector to another one in the same manner as the ISR_ALIASOF attribute for the <a class="el" href="group__avr__interrupts.html#gd28590624d422cdf30d626e0a506255f">ISR()</a> macro. Unlike the ISR_ALIASOF attribute macro however, this is compatible for all versions of GCC rather than just GCC version 4.2 onwards.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This macro creates a trampoline function for the aliased macro. This will result in a two cycle penalty for the aliased vector compared to the ISR the vector is aliased to, due to the JMP/RJMP opcode used.</dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>For new code, the use of ISR(..., ISR_ALIASOF(...)) is recommended.</dd></dl>
Example: <div class="fragment"><pre class="fragment">    <a class="code" href="group__avr__interrupts.html#gd28590624d422cdf30d626e0a506255f">ISR</a>(INT0_vect)
    {
        PORTB = 42;
    }

    <a class="code" href="group__avr__interrupts.html#gde46eb4e42cc9d56c19b1f91448f1b76">ISR_ALIAS</a>(INT1_vect, INT0_vect);
</pre></div> 
</div>
</div><p>
<a class="anchor" name="ga87c0c624b62f40a17539be6946c3e26"></a><!-- doxytag: member="interrupt.h::ISR_ALIASOF" ref="ga87c0c624b62f40a17539be6946c3e26" args="(target_vector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ISR_ALIASOF          </td>
          <td>(</td>
          <td class="paramtype">target_vector&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="interrupt_8h.html">avr/interrupt.h</a>&gt;</span>
</pre></div><p>
The ISR is linked to another ISR, specified by the vect parameter. This is compatible with GCC 4.2 and greater only.<p>
Use this attribute in the attributes parameter of the ISR macro. 
</div>
</div><p>
<a class="anchor" name="g5fc50a0507a58e16aca4c70345ddac6a"></a><!-- doxytag: member="interrupt.h::ISR_BLOCK" ref="g5fc50a0507a58e16aca4c70345ddac6a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ISR_BLOCK          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> # include &lt;<a class="code" href="interrupt_8h.html">avr/interrupt.h</a>&gt;</span> 
</pre></div><p>
Identical to an ISR with no attributes specified. Global interrupts are initially disabled by the AVR hardware when entering the ISR, without the compiler modifying this state.<p>
Use this attribute in the attributes parameter of the ISR macro. 
</div>
</div><p>
<a class="anchor" name="g8b4c7e44627db0a60d676213add42d64"></a><!-- doxytag: member="interrupt.h::ISR_NAKED" ref="g8b4c7e44627db0a60d676213add42d64" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ISR_NAKED          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> # include &lt;<a class="code" href="interrupt_8h.html">avr/interrupt.h</a>&gt;</span> 
</pre></div><p>
ISR is created with no prologue or epilogue code. The user code is responsible for preservation of the machine state including the SREG register, as well as placing a <a class="el" href="group__avr__interrupts.html#g3b991e8168db8fc866e31f9a6d10533b">reti()</a> at the end of the interrupt routine.<p>
Use this attribute in the attributes parameter of the ISR macro. 
</div>
</div><p>
<a class="anchor" name="g44569cb914d2aaf8fbb436f8f7c4ca68"></a><!-- doxytag: member="interrupt.h::ISR_NOBLOCK" ref="g44569cb914d2aaf8fbb436f8f7c4ca68" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ISR_NOBLOCK          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> # include &lt;<a class="code" href="interrupt_8h.html">avr/interrupt.h</a>&gt;</span> 
</pre></div><p>
ISR runs with global interrupts initially enabled. The interrupt enable flag is activated by the compiler as early as possible within the ISR to ensure minimal processing delay for nested interrupts.<p>
This may be used to create nested ISRs, however care should be taken to avoid stack overflows, or to avoid infinitely entering the ISR for those cases where the AVR hardware does not clear the respective interrupt flag before entering the ISR.<p>
Use this attribute in the attributes parameter of the ISR macro. 
</div>
</div><p>
<a class="anchor" name="g3b991e8168db8fc866e31f9a6d10533b"></a><!-- doxytag: member="interrupt.h::reti" ref="g3b991e8168db8fc866e31f9a6d10533b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define reti          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="interrupt_8h.html">avr/interrupt.h</a>&gt;</span> 
</pre></div><p>
Returns from an interrupt routine, enabling global interrupts. This should be the last command executed before leaving an ISR defined with the ISR_NAKED attribute.<p>
This macro actually compiles into a single line of assembly, so there is no function call overhead. 
</div>
</div><p>
<a class="anchor" name="gad5ebd34cb344c26ac87594f79b06b73"></a><!-- doxytag: member="interrupt.h::sei" ref="gad5ebd34cb344c26ac87594f79b06b73" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sei          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="interrupt_8h.html">avr/interrupt.h</a>&gt;</span> 
</pre></div><p>
Enables interrupts by setting the global interrupt mask. This function actually compiles into a single line of assembly, so there is no function call overhead. 
</div>
</div><p>
<a class="anchor" name="g67cd0dea412157775c2f2a3ffe9fb8ff"></a><!-- doxytag: member="interrupt.h::SIGNAL" ref="g67cd0dea412157775c2f2a3ffe9fb8ff" args="(vector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIGNAL          </td>
          <td>(</td>
          <td class="paramtype">vector&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="interrupt_8h.html">avr/interrupt.h</a>&gt;</span> 
</pre></div><p>
Introduces an interrupt handler function that runs with global interrupts initially disabled.<p>
This is the same as the ISR macro without optional attributes. <dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>Do not use <a class="el" href="group__avr__interrupts.html#g67cd0dea412157775c2f2a3ffe9fb8ff">SIGNAL()</a> in new code. Use <a class="el" href="group__avr__interrupts.html#gd28590624d422cdf30d626e0a506255f">ISR()</a> instead. </dd></dl>

</div>
</div><p>
</div>

<hr width="80%">
<p><center>Automatically generated by Doxygen 1.5.7 on 6 Nov 2008.</center></p>

</body>
</html>
