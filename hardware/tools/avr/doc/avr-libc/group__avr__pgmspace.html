<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
    <title>avr-libc: &lt;avr/pgmspace.h&gt;: Program Space Utilities</title>
    <link href="dox.css" rel="stylesheet" type="text/css">
  </head>
<body>
<center>
<table width="80%">
  <tr>
    <td align="left"><a href="http://www.nongnu.org/avr-libc/">AVR Libc Home Page</a></td>
    <td align="center" colspan=4><img src="avrs.png" alt="AVRs" align="middle" border="0"></td>
    <td align="right"><a href="https://savannah.nongnu.org/projects/avr-libc/">AVR Libc Development Pages</a></td>
  </tr>
  <tr>
    <td align="center" width="13%"><a href="index.html">Main Page</a></td>
    <td align="center" width="13%"><a href="pages.html">User Manual</a></td>
    <td align="center" width="13%"><a href="modules.html">Library Reference</a></td>
    <td align="center" width="13%"><a href="FAQ.html">FAQ</a></td>
    <td align="center" width="13%"><a href="globals.html">Alphabetical Index</a></td>
    <td align="center" width="13%"><a href="group__demos.html">Example Projects</a></td>
  </tr>
</table>
</center>
<hr width="80%">
<!-- Generated by Doxygen 1.5.7 -->
<div class="contents">
<h1>&lt;avr/pgmspace.h&gt;: Program Space Utilities</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#g75acaba9e781937468d0911423bc0c35">PROGMEM</a>&nbsp;&nbsp;&nbsp;__ATTR_PROGMEM__</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#g05ca900ebf7cd121be73c654d9ccb3eb">PSTR</a>(s)&nbsp;&nbsp;&nbsp;((const PROGMEM char *)(s))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#g88d7dd4863f87530e1a34ece430a587c">pgm_read_byte_near</a>(address_short)&nbsp;&nbsp;&nbsp;__LPM((<a class="el" href="group__avr__stdint.html#g1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>)(address_short))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gf51eeaa847dd2668d2a66b70ecfb7398">pgm_read_word_near</a>(address_short)&nbsp;&nbsp;&nbsp;__LPM_word((<a class="el" href="group__avr__stdint.html#g1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>)(address_short))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#g7fa92c0a662403a643859e0f33b0a182">pgm_read_dword_near</a>(address_short)&nbsp;&nbsp;&nbsp;__LPM_dword((<a class="el" href="group__avr__stdint.html#g1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>)(address_short))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#g066040df814dabc7980cd1422508b46b">pgm_read_float_near</a>(address_short)&nbsp;&nbsp;&nbsp;__LPM_float((<a class="el" href="group__avr__stdint.html#g1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>)(address_short))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#g0d4d7f6231716747c52b969d4febdeed">pgm_read_byte_far</a>(address_long)&nbsp;&nbsp;&nbsp;__ELPM((<a class="el" href="group__avr__stdint.html#g33594304e786b158f3fb30289278f5af">uint32_t</a>)(address_long))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gd7082c45c2c96f015c76eff1ad00a99a">pgm_read_word_far</a>(address_long)&nbsp;&nbsp;&nbsp;__ELPM_word((<a class="el" href="group__avr__stdint.html#g33594304e786b158f3fb30289278f5af">uint32_t</a>)(address_long))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#g309908c1b7430f0d140edb78fcf8f2b9">pgm_read_dword_far</a>(address_long)&nbsp;&nbsp;&nbsp;__ELPM_dword((<a class="el" href="group__avr__stdint.html#g33594304e786b158f3fb30289278f5af">uint32_t</a>)(address_long))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#g4a5a593aa84062ca08b3f2d564a6f466">pgm_read_float_far</a>(address_long)&nbsp;&nbsp;&nbsp;__ELPM_float((<a class="el" href="group__avr__stdint.html#g33594304e786b158f3fb30289278f5af">uint32_t</a>)(address_long))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#g73084a8bbde259ffae72980354b3f027">pgm_read_byte</a>(address_short)&nbsp;&nbsp;&nbsp;pgm_read_byte_near(address_short)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#g32d8ab354156f4b1ffdb77a275ba6223">pgm_read_word</a>(address_short)&nbsp;&nbsp;&nbsp;pgm_read_word_near(address_short)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gbb68859ac5dfa6a09ac048b4037a83b6">pgm_read_dword</a>(address_short)&nbsp;&nbsp;&nbsp;pgm_read_dword_near(address_short)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#g7911bddb066a8a038efc4b7857728fa8">pgm_read_float</a>(address_short)&nbsp;&nbsp;&nbsp;pgm_read_float_near(address_short)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#g963f816fc88a5d8479c285ed4c630229">PGM_P</a>&nbsp;&nbsp;&nbsp;const <a class="el" href="group__avr__pgmspace.html#ga475b6b81fd8b34de45695da1da523b6">prog_char</a> *</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#g84a61d55b7efefabd8419e28f02704f9">PGM_VOID_P</a>&nbsp;&nbsp;&nbsp;const <a class="el" href="group__avr__pgmspace.html#gdb50761b9f19d45449445208778ee420">prog_void</a> *</td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void PROGMEM&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gdb50761b9f19d45449445208778ee420">prog_void</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef char PROGMEM&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga475b6b81fd8b34de45695da1da523b6">prog_char</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef unsigned char PROGMEM&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#g7d4701843a2019e3ef5a9866dc7586ed">prog_uchar</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="group__avr__stdint.html#gef44329758059c91c76d334e8fc09700">int8_t</a> PROGMEM&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#g48c7cb011ea5f82f4b73df40e07dff46">prog_int8_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="group__avr__stdint.html#gba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> PROGMEM&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#g39235a28487ae7790ce5f4c8178c8ed7">prog_uint8_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="group__avr__stdint.html#g932e6ccc3d54c58f761c1aead83bd6d7">int16_t</a> PROGMEM&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gafc910d0b2c4d76afffa4710b98df6fa">prog_int16_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="group__avr__stdint.html#g1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a> PROGMEM&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#g93ec00229866bf6a125384ad08cefa73">prog_uint16_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="group__avr__stdint.html#gdb828ef50c2dbb783109824e94cf6c47">int32_t</a> PROGMEM&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga839901aa518fb43d361588dd8d2b44b">prog_int32_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="group__avr__stdint.html#g33594304e786b158f3fb30289278f5af">uint32_t</a> PROGMEM&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#g31bad0d22ead95a41e725c38ea63eb26">prog_uint32_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="group__avr__stdint.html#g831d6234342279926bb11bad3a37add9">int64_t</a> PROGMEM&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#g5b1f9927f06d841e9ac07af62e71cfef">prog_int64_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="group__avr__stdint.html#gd27ed092432b64ff558d2254c278720f">uint64_t</a> PROGMEM&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga50eebe90a40e0276bcc49ea0482b211">prog_uint64_t</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PGM_VOID_P&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#g287a70fef8531ad6aa9a2f73ee4fa162">memchr_P</a> (PGM_VOID_P, int __val, size_t __len)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#g51805e7bf43ffd1a70a045994a907768">memcmp_P</a> (const void *, PGM_VOID_P, size_t) __ATTR_PURE__</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#g53ee9e2dec1d5f685d78aa8dc444dccb">memcpy_P</a> (void *, PGM_VOID_P, size_t)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">PGM_VOID_P&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gb2614cd3f6b0196d3070b158f1ad05bd">memrchr_P</a> (PGM_VOID_P, int __val, size_t __len)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#g2e0ce009c836fed26221263d28c79b01">strcasecmp_P</a> (const char *, PGM_P) __ATTR_PURE__</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#g1617c6719e65951f109fe29b18c2bd35">strcat_P</a> (char *, PGM_P)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">PGM_P&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#g7c26394eea1ddcc33fb698833b9aa9b2">strchr_P</a> (PGM_P, int __val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">PGM_P&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gf5c3724d0e89d5952738b8c8da004e0a">strchrnul_P</a> (PGM_P, int __val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ge3a7686c2e207b543be3b402d919761a">strcmp_P</a> (const char *, PGM_P) __ATTR_PURE__</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#g9c3ff50bdf59b38219394ff5230660da">strcpy_P</a> (char *, PGM_P)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gee6bf291c23054aca37533937a1d412f">strcspn_P</a> (const char *__s, PGM_P __reject) __ATTR_PURE__</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#g484117e1416429fc94efad8c66643164">strlcat_P</a> (char *, PGM_P, size_t)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gabad6a32f133121973ea9c06e30cd33a">strlcpy_P</a> (char *, PGM_P, size_t)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#g3a8a479d2f1b4aef18a89316e3c9e0eb">strlen_P</a> (PGM_P)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gbe5f48c518cc38229d010467dda41d19">strncasecmp_P</a> (const char *, PGM_P, size_t) __ATTR_PURE__</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#g11ed791b5d147f8d2ce01699a9c220ca">strncat_P</a> (char *, PGM_P, size_t)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#g5048829165f57aef87bba38ba9126d1d">strncmp_P</a> (const char *, PGM_P, size_t) __ATTR_PURE__</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#g8283f9a987be92ae137ee610e6b11b90">strncpy_P</a> (char *, PGM_P, size_t)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#g8ece6c08cef78e50f404072823e48752">strnlen_P</a> (PGM_P, size_t)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gd6de880a1dd672b52469fe986e3ec011">strpbrk_P</a> (const char *__s, PGM_P __accept) __ATTR_PURE__</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">PGM_P&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gb3a5f8b6324d77903d713917eb219f05">strrchr_P</a> (PGM_P, int __val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#ga3bc55b47998e5ce1d8ddcf0be228638">strsep_P</a> (char **__sp, PGM_P __delim)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#g0ca5a2d8b5b1b4d899edb89535c36b69">strspn_P</a> (const char *__s, PGM_P __accept) __ATTR_PURE__</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#g36c9c2de19d7e23c4a6bf63eee608af3">strstr_P</a> (const char *, PGM_P) __ATTR_PURE__</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#g851eaa0bd303b445f6ea70db31059fef">memmem_P</a> (const void *, size_t, PGM_VOID_P, size_t) __ATTR_PURE__</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__pgmspace.html#gc75a4fcc7f301902eef58f8dea8e5cfd">strcasestr_P</a> (const char *, PGM_P) __ATTR_PURE__</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<div class="fragment"><pre class="fragment"><span class="preprocessor">    #include &lt;<a class="code" href="io_8h.html">avr/io.h</a>&gt;</span>
<span class="preprocessor">    #include &lt;<a class="code" href="pgmspace_8h.html">avr/pgmspace.h</a>&gt;</span>
</pre></div><p>
The functions in this module provide interfaces for a program to access data stored in program space (flash memory) of the device. In order to use these functions, the target device must support either the <code>LPM</code> or <code>ELPM</code> instructions.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>These functions are an attempt to provide some compatibility with header files that come with IAR C, to make porting applications between different compilers easier. This is not 100% compatibility though (GCC does not have full support for multiple address spaces yet).<p>
If you are working with strings which are completely based in ram, use the standard string functions described in <a class="el" href="group__avr__string.html">&lt;string.h&gt;: Strings</a>.<p>
If possible, put your constant tables in the lower 64 KB and use <a class="el" href="group__avr__pgmspace.html#g88d7dd4863f87530e1a34ece430a587c">pgm_read_byte_near()</a> or <a class="el" href="group__avr__pgmspace.html#gf51eeaa847dd2668d2a66b70ecfb7398">pgm_read_word_near()</a> instead of <a class="el" href="group__avr__pgmspace.html#g0d4d7f6231716747c52b969d4febdeed">pgm_read_byte_far()</a> or <a class="el" href="group__avr__pgmspace.html#gd7082c45c2c96f015c76eff1ad00a99a">pgm_read_word_far()</a> since it is more efficient that way, and you can still use the upper 64K for executable code. All functions that are suffixed with a <code>_P</code> <em>require</em> their arguments to be in the lower 64 KB of the flash ROM, as they do not use ELPM instructions. This is normally not a big concern as the linker setup arranges any program space constants declared using the macros from this header file so they are placed right after the interrupt vectors, and in front of any executable code. However, it can become a problem if there are too many of these constants, or for bootloaders on devices with more than 64 KB of ROM. <em>All these functions will not work in that situation.</em> </dd></dl>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="g963f816fc88a5d8479c285ed4c630229"></a><!-- doxytag: member="pgmspace.h::PGM_P" ref="g963f816fc88a5d8479c285ed4c630229" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PGM_P&nbsp;&nbsp;&nbsp;const <a class="el" href="group__avr__pgmspace.html#ga475b6b81fd8b34de45695da1da523b6">prog_char</a> *          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Used to declare a variable that is a pointer to a string in program space. 
</div>
</div><p>
<a class="anchor" name="g73084a8bbde259ffae72980354b3f027"></a><!-- doxytag: member="pgmspace.h::pgm_read_byte" ref="g73084a8bbde259ffae72980354b3f027" args="(address_short)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_byte          </td>
          <td>(</td>
          <td class="paramtype">address_short&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;pgm_read_byte_near(address_short)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read a byte from the program space with a 16-bit (near) address.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The address is a byte address. The address is in the program space. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g0d4d7f6231716747c52b969d4febdeed"></a><!-- doxytag: member="pgmspace.h::pgm_read_byte_far" ref="g0d4d7f6231716747c52b969d4febdeed" args="(address_long)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_byte_far          </td>
          <td>(</td>
          <td class="paramtype">address_long&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;__ELPM((<a class="el" href="group__avr__stdint.html#g33594304e786b158f3fb30289278f5af">uint32_t</a>)(address_long))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read a byte from the program space with a 32-bit (far) address.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The address is a byte address. The address is in the program space. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g88d7dd4863f87530e1a34ece430a587c"></a><!-- doxytag: member="pgmspace.h::pgm_read_byte_near" ref="g88d7dd4863f87530e1a34ece430a587c" args="(address_short)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_byte_near          </td>
          <td>(</td>
          <td class="paramtype">address_short&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;__LPM((<a class="el" href="group__avr__stdint.html#g1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>)(address_short))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read a byte from the program space with a 16-bit (near) address. <dl class="note" compact><dt><b>Note:</b></dt><dd>The address is a byte address. The address is in the program space. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gbb68859ac5dfa6a09ac048b4037a83b6"></a><!-- doxytag: member="pgmspace.h::pgm_read_dword" ref="gbb68859ac5dfa6a09ac048b4037a83b6" args="(address_short)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_dword          </td>
          <td>(</td>
          <td class="paramtype">address_short&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;pgm_read_dword_near(address_short)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read a double word from the program space with a 16-bit (near) address.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The address is a byte address. The address is in the program space. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g309908c1b7430f0d140edb78fcf8f2b9"></a><!-- doxytag: member="pgmspace.h::pgm_read_dword_far" ref="g309908c1b7430f0d140edb78fcf8f2b9" args="(address_long)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_dword_far          </td>
          <td>(</td>
          <td class="paramtype">address_long&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;__ELPM_dword((<a class="el" href="group__avr__stdint.html#g33594304e786b158f3fb30289278f5af">uint32_t</a>)(address_long))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read a double word from the program space with a 32-bit (far) address.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The address is a byte address. The address is in the program space. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g7fa92c0a662403a643859e0f33b0a182"></a><!-- doxytag: member="pgmspace.h::pgm_read_dword_near" ref="g7fa92c0a662403a643859e0f33b0a182" args="(address_short)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_dword_near          </td>
          <td>(</td>
          <td class="paramtype">address_short&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;__LPM_dword((<a class="el" href="group__avr__stdint.html#g1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>)(address_short))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read a double word from the program space with a 16-bit (near) address. <dl class="note" compact><dt><b>Note:</b></dt><dd>The address is a byte address. The address is in the program space. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g7911bddb066a8a038efc4b7857728fa8"></a><!-- doxytag: member="pgmspace.h::pgm_read_float" ref="g7911bddb066a8a038efc4b7857728fa8" args="(address_short)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_float          </td>
          <td>(</td>
          <td class="paramtype">address_short&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;pgm_read_float_near(address_short)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read a float from the program space with a 16-bit (near) address.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The address is a byte address. The address is in the program space. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g4a5a593aa84062ca08b3f2d564a6f466"></a><!-- doxytag: member="pgmspace.h::pgm_read_float_far" ref="g4a5a593aa84062ca08b3f2d564a6f466" args="(address_long)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_float_far          </td>
          <td>(</td>
          <td class="paramtype">address_long&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;__ELPM_float((<a class="el" href="group__avr__stdint.html#g33594304e786b158f3fb30289278f5af">uint32_t</a>)(address_long))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read a float from the program space with a 32-bit (far) address.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The address is a byte address. The address is in the program space. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g066040df814dabc7980cd1422508b46b"></a><!-- doxytag: member="pgmspace.h::pgm_read_float_near" ref="g066040df814dabc7980cd1422508b46b" args="(address_short)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_float_near          </td>
          <td>(</td>
          <td class="paramtype">address_short&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;__LPM_float((<a class="el" href="group__avr__stdint.html#g1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>)(address_short))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read a float from the program space with a 16-bit (near) address. <dl class="note" compact><dt><b>Note:</b></dt><dd>The address is a byte address. The address is in the program space. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g32d8ab354156f4b1ffdb77a275ba6223"></a><!-- doxytag: member="pgmspace.h::pgm_read_word" ref="g32d8ab354156f4b1ffdb77a275ba6223" args="(address_short)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_word          </td>
          <td>(</td>
          <td class="paramtype">address_short&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;pgm_read_word_near(address_short)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read a word from the program space with a 16-bit (near) address.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The address is a byte address. The address is in the program space. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gd7082c45c2c96f015c76eff1ad00a99a"></a><!-- doxytag: member="pgmspace.h::pgm_read_word_far" ref="gd7082c45c2c96f015c76eff1ad00a99a" args="(address_long)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_word_far          </td>
          <td>(</td>
          <td class="paramtype">address_long&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;__ELPM_word((<a class="el" href="group__avr__stdint.html#g33594304e786b158f3fb30289278f5af">uint32_t</a>)(address_long))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read a word from the program space with a 32-bit (far) address.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The address is a byte address. The address is in the program space. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf51eeaa847dd2668d2a66b70ecfb7398"></a><!-- doxytag: member="pgmspace.h::pgm_read_word_near" ref="gf51eeaa847dd2668d2a66b70ecfb7398" args="(address_short)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pgm_read_word_near          </td>
          <td>(</td>
          <td class="paramtype">address_short&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;__LPM_word((<a class="el" href="group__avr__stdint.html#g1f1825b69244eb3ad2c7165ddc99c956">uint16_t</a>)(address_short))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read a word from the program space with a 16-bit (near) address. <dl class="note" compact><dt><b>Note:</b></dt><dd>The address is a byte address. The address is in the program space. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g84a61d55b7efefabd8419e28f02704f9"></a><!-- doxytag: member="pgmspace.h::PGM_VOID_P" ref="g84a61d55b7efefabd8419e28f02704f9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PGM_VOID_P&nbsp;&nbsp;&nbsp;const <a class="el" href="group__avr__pgmspace.html#gdb50761b9f19d45449445208778ee420">prog_void</a> *          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Used to declare a generic pointer to an object in program space. 
</div>
</div><p>
<a class="anchor" name="g75acaba9e781937468d0911423bc0c35"></a><!-- doxytag: member="pgmspace.h::PROGMEM" ref="g75acaba9e781937468d0911423bc0c35" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PROGMEM&nbsp;&nbsp;&nbsp;__ATTR_PROGMEM__          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attribute to use in order to declare an object being located in flash ROM. 
</div>
</div><p>
<a class="anchor" name="g05ca900ebf7cd121be73c654d9ccb3eb"></a><!-- doxytag: member="pgmspace.h::PSTR" ref="g05ca900ebf7cd121be73c654d9ccb3eb" args="(s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PSTR          </td>
          <td>(</td>
          <td class="paramtype">s&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((const PROGMEM char *)(s))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Used to declare a static pointer to a string in program space. 
</div>
</div><p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="ga475b6b81fd8b34de45695da1da523b6"></a><!-- doxytag: member="pgmspace.h::prog_char" ref="ga475b6b81fd8b34de45695da1da523b6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__avr__pgmspace.html#ga475b6b81fd8b34de45695da1da523b6">prog_char</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of a "char" object located in flash ROM. 
</div>
</div><p>
<a class="anchor" name="gafc910d0b2c4d76afffa4710b98df6fa"></a><!-- doxytag: member="pgmspace.h::prog_int16_t" ref="gafc910d0b2c4d76afffa4710b98df6fa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__avr__pgmspace.html#gafc910d0b2c4d76afffa4710b98df6fa">prog_int16_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of an "int16_t" object located in flash ROM. 
</div>
</div><p>
<a class="anchor" name="ga839901aa518fb43d361588dd8d2b44b"></a><!-- doxytag: member="pgmspace.h::prog_int32_t" ref="ga839901aa518fb43d361588dd8d2b44b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__avr__pgmspace.html#ga839901aa518fb43d361588dd8d2b44b">prog_int32_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of an "int32_t" object located in flash ROM. 
</div>
</div><p>
<a class="anchor" name="g5b1f9927f06d841e9ac07af62e71cfef"></a><!-- doxytag: member="pgmspace.h::prog_int64_t" ref="g5b1f9927f06d841e9ac07af62e71cfef" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__avr__pgmspace.html#g5b1f9927f06d841e9ac07af62e71cfef">prog_int64_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of an "int64_t" object located in flash ROM.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This type is not available when the compiler option -mint8 is in effect. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g48c7cb011ea5f82f4b73df40e07dff46"></a><!-- doxytag: member="pgmspace.h::prog_int8_t" ref="g48c7cb011ea5f82f4b73df40e07dff46" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__avr__pgmspace.html#g48c7cb011ea5f82f4b73df40e07dff46">prog_int8_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of an "int8_t" object located in flash ROM. 
</div>
</div><p>
<a class="anchor" name="g7d4701843a2019e3ef5a9866dc7586ed"></a><!-- doxytag: member="pgmspace.h::prog_uchar" ref="g7d4701843a2019e3ef5a9866dc7586ed" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__avr__pgmspace.html#g7d4701843a2019e3ef5a9866dc7586ed">prog_uchar</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of an "unsigned char" object located in flash ROM. 
</div>
</div><p>
<a class="anchor" name="g93ec00229866bf6a125384ad08cefa73"></a><!-- doxytag: member="pgmspace.h::prog_uint16_t" ref="g93ec00229866bf6a125384ad08cefa73" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__avr__pgmspace.html#g93ec00229866bf6a125384ad08cefa73">prog_uint16_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of an "uint16_t" object located in flash ROM. 
</div>
</div><p>
<a class="anchor" name="g31bad0d22ead95a41e725c38ea63eb26"></a><!-- doxytag: member="pgmspace.h::prog_uint32_t" ref="g31bad0d22ead95a41e725c38ea63eb26" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__avr__pgmspace.html#g31bad0d22ead95a41e725c38ea63eb26">prog_uint32_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of an "uint32_t" object located in flash ROM. 
</div>
</div><p>
<a class="anchor" name="ga50eebe90a40e0276bcc49ea0482b211"></a><!-- doxytag: member="pgmspace.h::prog_uint64_t" ref="ga50eebe90a40e0276bcc49ea0482b211" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__avr__pgmspace.html#ga50eebe90a40e0276bcc49ea0482b211">prog_uint64_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of an "uint64_t" object located in flash ROM.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This type is not available when the compiler option -mint8 is in effect. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g39235a28487ae7790ce5f4c8178c8ed7"></a><!-- doxytag: member="pgmspace.h::prog_uint8_t" ref="g39235a28487ae7790ce5f4c8178c8ed7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__avr__pgmspace.html#g39235a28487ae7790ce5f4c8178c8ed7">prog_uint8_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of an "uint8_t" object located in flash ROM. 
</div>
</div><p>
<a class="anchor" name="gdb50761b9f19d45449445208778ee420"></a><!-- doxytag: member="pgmspace.h::prog_void" ref="gdb50761b9f19d45449445208778ee420" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__avr__pgmspace.html#gdb50761b9f19d45449445208778ee420">prog_void</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of a "void" object located in flash ROM. Does not make much sense by itself, but can be used to declare a "void *" object in flash ROM. 
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g287a70fef8531ad6aa9a2f73ee4fa162"></a><!-- doxytag: member="pgmspace.h::memchr_P" ref="g287a70fef8531ad6aa9a2f73ee4fa162" args="(PGM_VOID_P, int __val, size_t __len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PGM_VOID_P memchr_P           </td>
          <td>(</td>
          <td class="paramtype">PGM_VOID_P&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Scan flash memory for a character. 
<p>
The <a class="el" href="group__avr__pgmspace.html#g287a70fef8531ad6aa9a2f73ee4fa162" title="Scan flash memory for a character.">memchr_P()</a> function scans the first <code>len</code> bytes of the flash memory area pointed to by <code>s</code> for the character <code>val</code>. The first byte to match <code>val</code> (interpreted as an unsigned character) stops the operation.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="group__avr__pgmspace.html#g287a70fef8531ad6aa9a2f73ee4fa162" title="Scan flash memory for a character.">memchr_P()</a> function returns a pointer to the matching byte or <code>NULL</code> if the character does not occur in the given memory area. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g51805e7bf43ffd1a70a045994a907768"></a><!-- doxytag: member="pgmspace.h::memcmp_P" ref="g51805e7bf43ffd1a70a045994a907768" args="(const void *, PGM_VOID_P, size_t) __ATTR_PURE__" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int memcmp_P           </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGM_VOID_P&nbsp;</td>
          <td class="paramname"> <em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compare memory areas. 
<p>
The <a class="el" href="group__avr__pgmspace.html#g51805e7bf43ffd1a70a045994a907768" title="Compare memory areas.">memcmp_P()</a> function compares the first <code>len</code> bytes of the memory areas <code>s1</code> and flash <code>s2</code>. The comparision is performed using unsigned char operations.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="group__avr__pgmspace.html#g51805e7bf43ffd1a70a045994a907768" title="Compare memory areas.">memcmp_P()</a> function returns an integer less than, equal to, or greater than zero if the first <code>len</code> bytes of <code>s1</code> is found, respectively, to be less than, to match, or be greater than the first <code>len</code> bytes of <code>s2</code>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g53ee9e2dec1d5f685d78aa8dc444dccb"></a><!-- doxytag: member="pgmspace.h::memcpy_P" ref="g53ee9e2dec1d5f685d78aa8dc444dccb" args="(void *, PGM_VOID_P, size_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * memcpy_P           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGM_VOID_P&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The <a class="el" href="group__avr__pgmspace.html#g53ee9e2dec1d5f685d78aa8dc444dccb">memcpy_P()</a> function is similar to <a class="el" href="group__avr__string.html#g5f60008005ea7557430149926cf583d7" title="Copy a memory area.">memcpy()</a>, except the src string resides in program space.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="group__avr__pgmspace.html#g53ee9e2dec1d5f685d78aa8dc444dccb">memcpy_P()</a> function returns a pointer to dest. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g851eaa0bd303b445f6ea70db31059fef"></a><!-- doxytag: member="pgmspace.h::memmem_P" ref="g851eaa0bd303b445f6ea70db31059fef" args="(const void *, size_t, PGM_VOID_P, size_t) __ATTR_PURE__" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * memmem_P           </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGM_VOID_P&nbsp;</td>
          <td class="paramname"> <em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The <a class="el" href="group__avr__pgmspace.html#g851eaa0bd303b445f6ea70db31059fef">memmem_P()</a> function is similar to <a class="el" href="group__avr__string.html#g1c22a39c9d936f18aa0764e331e3cddc">memmem()</a> except that <code>s2</code> is pointer to a string in program space. 
</div>
</div><p>
<a class="anchor" name="gb2614cd3f6b0196d3070b158f1ad05bd"></a><!-- doxytag: member="pgmspace.h::memrchr_P" ref="gb2614cd3f6b0196d3070b158f1ad05bd" args="(PGM_VOID_P, int __val, size_t __len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PGM_VOID_P memrchr_P           </td>
          <td>(</td>
          <td class="paramtype">PGM_VOID_P&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The <a class="el" href="group__avr__pgmspace.html#gb2614cd3f6b0196d3070b158f1ad05bd">memrchr_P()</a> function is like the <a class="el" href="group__avr__pgmspace.html#g287a70fef8531ad6aa9a2f73ee4fa162" title="Scan flash memory for a character.">memchr_P()</a> function, except that it searches backwards from the end of the <code>len</code> bytes pointed to by <code>src</code> instead of forwards from the front. (Glibc, GNU extension.)<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="group__avr__pgmspace.html#gb2614cd3f6b0196d3070b158f1ad05bd">memrchr_P()</a> function returns a pointer to the matching byte or <code>NULL</code> if the character does not occur in the given memory area. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g2e0ce009c836fed26221263d28c79b01"></a><!-- doxytag: member="pgmspace.h::strcasecmp_P" ref="g2e0ce009c836fed26221263d28c79b01" args="(const char *, PGM_P) __ATTR_PURE__" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int strcasecmp_P           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGM_P&nbsp;</td>
          <td class="paramname"> <em>s2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compare two strings ignoring case. 
<p>
The <a class="el" href="group__avr__pgmspace.html#g2e0ce009c836fed26221263d28c79b01" title="Compare two strings ignoring case.">strcasecmp_P()</a> function compares the two strings <code>s1</code> and <code>s2</code>, ignoring the case of the characters.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s1</em>&nbsp;</td><td>A pointer to a string in the devices SRAM. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s2</em>&nbsp;</td><td>A pointer to a string in the devices Flash.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="group__avr__pgmspace.html#g2e0ce009c836fed26221263d28c79b01" title="Compare two strings ignoring case.">strcasecmp_P()</a> function returns an integer less than, equal to, or greater than zero if <code>s1</code> is found, respectively, to be less than, to match, or be greater than <code>s2</code>. A consequence of the ordering used by <a class="el" href="group__avr__pgmspace.html#g2e0ce009c836fed26221263d28c79b01" title="Compare two strings ignoring case.">strcasecmp_P()</a> is that if <code>s1</code> is an initial substring of <code>s2</code>, then <code>s1</code> is considered to be "less than" <code>s2</code>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gc75a4fcc7f301902eef58f8dea8e5cfd"></a><!-- doxytag: member="pgmspace.h::strcasestr_P" ref="gc75a4fcc7f301902eef58f8dea8e5cfd" args="(const char *, PGM_P) __ATTR_PURE__" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strcasestr_P           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGM_P&nbsp;</td>
          <td class="paramname"> <em>s2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This funtion is similar to <a class="el" href="group__avr__string.html#ge240697c78aee7b9c47cb2c9452526ea">strcasestr()</a> except that <code>s2</code> is pointer to a string in program space. 
</div>
</div><p>
<a class="anchor" name="g1617c6719e65951f109fe29b18c2bd35"></a><!-- doxytag: member="pgmspace.h::strcat_P" ref="g1617c6719e65951f109fe29b18c2bd35" args="(char *, PGM_P)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strcat_P           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGM_P&nbsp;</td>
          <td class="paramname"> <em>src</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The <a class="el" href="group__avr__pgmspace.html#g1617c6719e65951f109fe29b18c2bd35">strcat_P()</a> function is similar to <a class="el" href="group__avr__string.html#g1fd2a6e188f02599e5eeb17519f67f3e" title="Concatenate two strings.">strcat()</a> except that the <em>src</em> string must be located in program space (flash).<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="group__avr__string.html#g1fd2a6e188f02599e5eeb17519f67f3e" title="Concatenate two strings.">strcat()</a> function returns a pointer to the resulting string <em>dest</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g7c26394eea1ddcc33fb698833b9aa9b2"></a><!-- doxytag: member="pgmspace.h::strchr_P" ref="g7c26394eea1ddcc33fb698833b9aa9b2" args="(PGM_P, int __val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PGM_P strchr_P           </td>
          <td>(</td>
          <td class="paramtype">PGM_P&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Locate character in program space string. 
<p>
The <a class="el" href="group__avr__pgmspace.html#g7c26394eea1ddcc33fb698833b9aa9b2" title="Locate character in program space string.">strchr_P()</a> function locates the first occurrence of <code>val</code> (converted to a char) in the string pointed to by <code>s</code> in program space. The terminating null character is considered to be part of the string.<p>
The <a class="el" href="group__avr__pgmspace.html#g7c26394eea1ddcc33fb698833b9aa9b2" title="Locate character in program space string.">strchr_P()</a> function is similar to <a class="el" href="group__avr__string.html#g4a03589020c79fa0b93673634bef711b" title="Locate character in string.">strchr()</a> except that <code>s</code> is pointer to a string in program space.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="group__avr__pgmspace.html#g7c26394eea1ddcc33fb698833b9aa9b2" title="Locate character in program space string.">strchr_P()</a> function returns a pointer to the matched character or <code>NULL</code> if the character is not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf5c3724d0e89d5952738b8c8da004e0a"></a><!-- doxytag: member="pgmspace.h::strchrnul_P" ref="gf5c3724d0e89d5952738b8c8da004e0a" args="(PGM_P, int __val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PGM_P strchrnul_P           </td>
          <td>(</td>
          <td class="paramtype">PGM_P&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The <a class="el" href="group__avr__pgmspace.html#gf5c3724d0e89d5952738b8c8da004e0a">strchrnul_P()</a> function is like <a class="el" href="group__avr__pgmspace.html#g7c26394eea1ddcc33fb698833b9aa9b2" title="Locate character in program space string.">strchr_P()</a> except that if <code>c</code> is not found in <code>s</code>, then it returns a pointer to the null byte at the end of <code>s</code>, rather than <code>NULL</code>. (Glibc, GNU extension.)<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="group__avr__pgmspace.html#gf5c3724d0e89d5952738b8c8da004e0a">strchrnul_P()</a> function returns a pointer to the matched character, or a pointer to the null byte at the end of <code>s</code> (i.e., <code>s+strlen</code>(s)) if the character is not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ge3a7686c2e207b543be3b402d919761a"></a><!-- doxytag: member="pgmspace.h::strcmp_P" ref="ge3a7686c2e207b543be3b402d919761a" args="(const char *, PGM_P) __ATTR_PURE__" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int strcmp_P           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGM_P&nbsp;</td>
          <td class="paramname"> <em>s2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The <a class="el" href="group__avr__pgmspace.html#ge3a7686c2e207b543be3b402d919761a">strcmp_P()</a> function is similar to <a class="el" href="group__avr__string.html#g46f3cbd2de457c0fb340a1f379fc33ba" title="Compare two strings.">strcmp()</a> except that <code>s2</code> is pointer to a string in program space.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="group__avr__pgmspace.html#ge3a7686c2e207b543be3b402d919761a">strcmp_P()</a> function returns an integer less than, equal to, or greater than zero if <code>s1</code> is found, respectively, to be less than, to match, or be greater than <code>s2</code>. A consequence of the ordering used by <a class="el" href="group__avr__pgmspace.html#ge3a7686c2e207b543be3b402d919761a">strcmp_P()</a> is that if <code>s1</code> is an initial substring of <code>s2</code>, then <code>s1</code> is considered to be "less than" <code>s2</code>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g9c3ff50bdf59b38219394ff5230660da"></a><!-- doxytag: member="pgmspace.h::strcpy_P" ref="g9c3ff50bdf59b38219394ff5230660da" args="(char *, PGM_P)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strcpy_P           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGM_P&nbsp;</td>
          <td class="paramname"> <em>src</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The <a class="el" href="group__avr__pgmspace.html#g9c3ff50bdf59b38219394ff5230660da">strcpy_P()</a> function is similar to <a class="el" href="group__avr__string.html#g54e4f23104fa6f722f9459d2673a1eba" title="Copy a string.">strcpy()</a> except that src is a pointer to a string in program space.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="group__avr__pgmspace.html#g9c3ff50bdf59b38219394ff5230660da">strcpy_P()</a> function returns a pointer to the destination string dest. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gee6bf291c23054aca37533937a1d412f"></a><!-- doxytag: member="pgmspace.h::strcspn_P" ref="gee6bf291c23054aca37533937a1d412f" args="(const char *__s, PGM_P __reject) __ATTR_PURE__" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t strcspn_P           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGM_P&nbsp;</td>
          <td class="paramname"> <em>reject</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The <a class="el" href="group__avr__pgmspace.html#gee6bf291c23054aca37533937a1d412f">strcspn_P()</a> function calculates the length of the initial segment of <code>s</code> which consists entirely of characters not in <code>reject</code>. This function is similar to <a class="el" href="group__avr__string.html#g53e212c1732d63bc80f649e542aff120">strcspn()</a> except that <code>reject</code> is a pointer to a string in program space.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="group__avr__pgmspace.html#gee6bf291c23054aca37533937a1d412f">strcspn_P()</a> function returns the number of characters in the initial segment of <code>s</code> which are not in the string <code>reject</code>. The terminating zero is not considered as a part of string. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g484117e1416429fc94efad8c66643164"></a><!-- doxytag: member="pgmspace.h::strlcat_P" ref="g484117e1416429fc94efad8c66643164" args="(char *, PGM_P, size_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t strlcat_P           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGM_P&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>siz</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Concatenate two strings. 
<p>
The <a class="el" href="group__avr__pgmspace.html#g484117e1416429fc94efad8c66643164" title="Concatenate two strings.">strlcat_P()</a> function is similar to <a class="el" href="group__avr__string.html#g63e609bfa0d354dcd7e35b297c2e6fdd" title="Concatenate two strings.">strlcat()</a>, except that the <em>src</em> string must be located in program space (flash).<p>
Appends src to string dst of size siz (unlike <a class="el" href="group__avr__string.html#gfa4a8701698b766f40180c735726cfe7" title="Concatenate two strings.">strncat()</a>, siz is the full size of dst, not space left). At most siz-1 characters will be copied. Always NULL terminates (unless siz &lt;= strlen(dst)).<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="group__avr__pgmspace.html#g484117e1416429fc94efad8c66643164" title="Concatenate two strings.">strlcat_P()</a> function returns strlen(src) + MIN(siz, strlen(initial dst)). If retval &gt;= siz, truncation occurred. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gabad6a32f133121973ea9c06e30cd33a"></a><!-- doxytag: member="pgmspace.h::strlcpy_P" ref="gabad6a32f133121973ea9c06e30cd33a" args="(char *, PGM_P, size_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t strlcpy_P           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGM_P&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>siz</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy a string from progmem to RAM. 
<p>
Copy src to string dst of size siz. At most siz-1 characters will be copied. Always NULL terminates (unless siz == 0).<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="group__avr__pgmspace.html#gabad6a32f133121973ea9c06e30cd33a" title="Copy a string from progmem to RAM.">strlcpy_P()</a> function returns strlen(src). If retval &gt;= siz, truncation occurred. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g3a8a479d2f1b4aef18a89316e3c9e0eb"></a><!-- doxytag: member="pgmspace.h::strlen_P" ref="g3a8a479d2f1b4aef18a89316e3c9e0eb" args="(PGM_P)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t strlen_P           </td>
          <td>(</td>
          <td class="paramtype">PGM_P&nbsp;</td>
          <td class="paramname"> <em>src</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The <a class="el" href="group__avr__pgmspace.html#g3a8a479d2f1b4aef18a89316e3c9e0eb">strlen_P()</a> function is similar to <a class="el" href="group__avr__string.html#g7fd4936b86eb6b87e98587044c562715" title="Calculate the length of a string.">strlen()</a>, except that src is a pointer to a string in program space.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="group__avr__string.html#g7fd4936b86eb6b87e98587044c562715" title="Calculate the length of a string.">strlen()</a> function returns the number of characters in src. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gbe5f48c518cc38229d010467dda41d19"></a><!-- doxytag: member="pgmspace.h::strncasecmp_P" ref="gbe5f48c518cc38229d010467dda41d19" args="(const char *, PGM_P, size_t) __ATTR_PURE__" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int strncasecmp_P           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGM_P&nbsp;</td>
          <td class="paramname"> <em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compare two strings ignoring case. 
<p>
The <a class="el" href="group__avr__pgmspace.html#gbe5f48c518cc38229d010467dda41d19" title="Compare two strings ignoring case.">strncasecmp_P()</a> function is similar to <a class="el" href="group__avr__pgmspace.html#g2e0ce009c836fed26221263d28c79b01" title="Compare two strings ignoring case.">strcasecmp_P()</a>, except it only compares the first <code>n</code> characters of <code>s1</code>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s1</em>&nbsp;</td><td>A pointer to a string in the devices SRAM. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s2</em>&nbsp;</td><td>A pointer to a string in the devices Flash. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>The maximum number of bytes to compare.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="group__avr__pgmspace.html#gbe5f48c518cc38229d010467dda41d19" title="Compare two strings ignoring case.">strncasecmp_P()</a> function returns an integer less than, equal to, or greater than zero if <code>s1</code> (or the first <code>n</code> bytes thereof) is found, respectively, to be less than, to match, or be greater than <code>s2</code>. A consequence of the ordering used by <a class="el" href="group__avr__pgmspace.html#gbe5f48c518cc38229d010467dda41d19" title="Compare two strings ignoring case.">strncasecmp_P()</a> is that if <code>s1</code> is an initial substring of <code>s2</code>, then <code>s1</code> is considered to be "less than" <code>s2</code>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g11ed791b5d147f8d2ce01699a9c220ca"></a><!-- doxytag: member="pgmspace.h::strncat_P" ref="g11ed791b5d147f8d2ce01699a9c220ca" args="(char *, PGM_P, size_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strncat_P           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGM_P&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Concatenate two strings. 
<p>
The <a class="el" href="group__avr__pgmspace.html#g11ed791b5d147f8d2ce01699a9c220ca" title="Concatenate two strings.">strncat_P()</a> function is similar to <a class="el" href="group__avr__string.html#gfa4a8701698b766f40180c735726cfe7" title="Concatenate two strings.">strncat()</a>, except that the <em>src</em> string must be located in program space (flash).<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="group__avr__pgmspace.html#g11ed791b5d147f8d2ce01699a9c220ca" title="Concatenate two strings.">strncat_P()</a> function returns a pointer to the resulting string dest. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g5048829165f57aef87bba38ba9126d1d"></a><!-- doxytag: member="pgmspace.h::strncmp_P" ref="g5048829165f57aef87bba38ba9126d1d" args="(const char *, PGM_P, size_t) __ATTR_PURE__" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int strncmp_P           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGM_P&nbsp;</td>
          <td class="paramname"> <em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The <a class="el" href="group__avr__pgmspace.html#g5048829165f57aef87bba38ba9126d1d">strncmp_P()</a> function is similar to <a class="el" href="group__avr__pgmspace.html#ge3a7686c2e207b543be3b402d919761a">strcmp_P()</a> except it only compares the first (at most) n characters of s1 and s2.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="group__avr__pgmspace.html#g5048829165f57aef87bba38ba9126d1d">strncmp_P()</a> function returns an integer less than, equal to, or greater than zero if s1 (or the first n bytes thereof) is found, respectively, to be less than, to match, or be greater than s2. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g8283f9a987be92ae137ee610e6b11b90"></a><!-- doxytag: member="pgmspace.h::strncpy_P" ref="g8283f9a987be92ae137ee610e6b11b90" args="(char *, PGM_P, size_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strncpy_P           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGM_P&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The <a class="el" href="group__avr__pgmspace.html#g8283f9a987be92ae137ee610e6b11b90">strncpy_P()</a> function is similar to <a class="el" href="group__avr__pgmspace.html#g9c3ff50bdf59b38219394ff5230660da">strcpy_P()</a> except that not more than n bytes of src are copied. Thus, if there is no null byte among the first n bytes of src, the result will not be null-terminated.<p>
In the case where the length of src is less than that of n, the remainder of dest will be padded with nulls.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="group__avr__pgmspace.html#g8283f9a987be92ae137ee610e6b11b90">strncpy_P()</a> function returns a pointer to the destination string dest. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g8ece6c08cef78e50f404072823e48752"></a><!-- doxytag: member="pgmspace.h::strnlen_P" ref="g8ece6c08cef78e50f404072823e48752" args="(PGM_P, size_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t strnlen_P           </td>
          <td>(</td>
          <td class="paramtype">PGM_P&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine the length of a fixed-size string. 
<p>
The <a class="el" href="group__avr__pgmspace.html#g8ece6c08cef78e50f404072823e48752" title="Determine the length of a fixed-size string.">strnlen_P()</a> function is similar to <a class="el" href="group__avr__string.html#g3d3e512a095039a7e2f86859537d761b" title="Determine the length of a fixed-size string.">strnlen()</a>, except that <code>src</code> is a pointer to a string in program space.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The strnlen_P function returns strlen_P(src), if that is less than <code>len</code>, or <code>len</code> if there is no '\0' character among the first <code>len</code> characters pointed to by <code>src</code>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gd6de880a1dd672b52469fe986e3ec011"></a><!-- doxytag: member="pgmspace.h::strpbrk_P" ref="gd6de880a1dd672b52469fe986e3ec011" args="(const char *__s, PGM_P __accept) __ATTR_PURE__" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strpbrk_P           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGM_P&nbsp;</td>
          <td class="paramname"> <em>accept</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The <a class="el" href="group__avr__pgmspace.html#gd6de880a1dd672b52469fe986e3ec011">strpbrk_P()</a> function locates the first occurrence in the string <code>s</code> of any of the characters in the flash string <code>accept</code>. This function is similar to <a class="el" href="group__avr__string.html#g386481b53df5f2437a1da78b400b6440">strpbrk()</a> except that <code>accept</code> is a pointer to a string in program space.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="group__avr__pgmspace.html#gd6de880a1dd672b52469fe986e3ec011">strpbrk_P()</a> function returns a pointer to the character in <code>s</code> that matches one of the characters in <code>accept</code>, or <code>NULL</code> if no such character is found. The terminating zero is not considered as a part of string: if one or both args are empty, the result will <code>NULL</code>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb3a5f8b6324d77903d713917eb219f05"></a><!-- doxytag: member="pgmspace.h::strrchr_P" ref="gb3a5f8b6324d77903d713917eb219f05" args="(PGM_P, int __val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PGM_P strrchr_P           </td>
          <td>(</td>
          <td class="paramtype">PGM_P&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Locate character in string. 
<p>
The <a class="el" href="group__avr__pgmspace.html#gb3a5f8b6324d77903d713917eb219f05" title="Locate character in string.">strrchr_P()</a> function returns a pointer to the last occurrence of the character <code>val</code> in the flash string <code>s</code>.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="group__avr__pgmspace.html#gb3a5f8b6324d77903d713917eb219f05" title="Locate character in string.">strrchr_P()</a> function returns a pointer to the matched character or <code>NULL</code> if the character is not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ga3bc55b47998e5ce1d8ddcf0be228638"></a><!-- doxytag: member="pgmspace.h::strsep_P" ref="ga3bc55b47998e5ce1d8ddcf0be228638" args="(char **__sp, PGM_P __delim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strsep_P           </td>
          <td>(</td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGM_P&nbsp;</td>
          <td class="paramname"> <em>delim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parse a string into tokens. 
<p>
The <a class="el" href="group__avr__pgmspace.html#ga3bc55b47998e5ce1d8ddcf0be228638" title="Parse a string into tokens.">strsep_P()</a> function locates, in the string referenced by <code>*sp</code>, the first occurrence of any character in the string <code>delim</code> (or the terminating '\0' character) and replaces it with a '\0'. The location of the next character after the delimiter character (or <code>NULL</code>, if the end of the string was reached) is stored in <code>*sp</code>. An ``empty'' field, i.e. one caused by two adjacent delimiter characters, can be detected by comparing the location referenced by the pointer returned in <code>*sp</code> to '\0'. This function is similar to <a class="el" href="group__avr__string.html#gff88adec2ad0446259766197ec3863de" title="Parse a string into tokens.">strsep()</a> except that <code>delim</code> is a pointer to a string in program space.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="group__avr__pgmspace.html#ga3bc55b47998e5ce1d8ddcf0be228638" title="Parse a string into tokens.">strsep_P()</a> function returns a pointer to the original value of <code>*sp</code>. If <code>*sp</code> is initially <code>NULL</code>, <a class="el" href="group__avr__pgmspace.html#ga3bc55b47998e5ce1d8ddcf0be228638" title="Parse a string into tokens.">strsep_P()</a> returns <code>NULL</code>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g0ca5a2d8b5b1b4d899edb89535c36b69"></a><!-- doxytag: member="pgmspace.h::strspn_P" ref="g0ca5a2d8b5b1b4d899edb89535c36b69" args="(const char *__s, PGM_P __accept) __ATTR_PURE__" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t strspn_P           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGM_P&nbsp;</td>
          <td class="paramname"> <em>accept</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The <a class="el" href="group__avr__pgmspace.html#g0ca5a2d8b5b1b4d899edb89535c36b69">strspn_P()</a> function calculates the length of the initial segment of <code>s</code> which consists entirely of characters in <code>accept</code>. This function is similar to <a class="el" href="group__avr__string.html#gcbc51d76d5f8f4cacf27238494d866d8">strspn()</a> except that <code>accept</code> is a pointer to a string in program space.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="group__avr__pgmspace.html#g0ca5a2d8b5b1b4d899edb89535c36b69">strspn_P()</a> function returns the number of characters in the initial segment of <code>s</code> which consist only of characters from <code>accept</code>. The terminating zero is not considered as a part of string. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g36c9c2de19d7e23c4a6bf63eee608af3"></a><!-- doxytag: member="pgmspace.h::strstr_P" ref="g36c9c2de19d7e23c4a6bf63eee608af3" args="(const char *, PGM_P) __ATTR_PURE__" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * strstr_P           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PGM_P&nbsp;</td>
          <td class="paramname"> <em>s2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Locate a substring. 
<p>
The <a class="el" href="group__avr__pgmspace.html#g36c9c2de19d7e23c4a6bf63eee608af3" title="Locate a substring.">strstr_P()</a> function finds the first occurrence of the substring <code>s2</code> in the string <code>s1</code>. The terminating '\0' characters are not compared. The <a class="el" href="group__avr__pgmspace.html#g36c9c2de19d7e23c4a6bf63eee608af3" title="Locate a substring.">strstr_P()</a> function is similar to <a class="el" href="group__avr__string.html#g6a441da9211eb85881d99c60b1003552" title="Locate a substring.">strstr()</a> except that <code>s2</code> is pointer to a string in program space.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="group__avr__pgmspace.html#g36c9c2de19d7e23c4a6bf63eee608af3" title="Locate a substring.">strstr_P()</a> function returns a pointer to the beginning of the substring, or NULL if the substring is not found. If <code>s2</code> points to a string of zero length, the function returns <code>s1</code>. </dd></dl>

</div>
</div><p>
</div>

<hr width="80%">
<p><center>Automatically generated by Doxygen 1.5.7 on 6 Nov 2008.</center></p>

</body>
</html>
